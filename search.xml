<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的博客</title>
    <url>/2023/01/31/template/</url>
    <content><![CDATA[<p>我的第一篇博客</p>
<span id="more"></span>

<p>正片开始</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">关系模型</span><br><span class="line">关系代数</span><br><span class="line"></span><br><span class="line">parser</span><br><span class="line">	词法</span><br><span class="line">	语法</span><br><span class="line">	</span><br><span class="line">AST</span><br><span class="line"></span><br><span class="line">planner</span><br><span class="line">	启发式（Heuristics）</span><br><span class="line">	启发式+基于代价的JOIN（Heuristics + Cost-based Join Order Search）</span><br><span class="line">	分层优化器框架（Stratified Search）</span><br><span class="line">	统一优化器框架（Unified Search）</span><br><span class="line">	</span><br><span class="line">	system-r</span><br><span class="line">	v</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>template</category>
      </categories>
      <tags>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议深入理解</title>
    <url>/2023/01/31/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/template/</url>
    <content><![CDATA[<span id="more"></span>







]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 模版元编程</title>
    <url>/2023/05/26/3-c++/00-%E6%A8%A1%E7%89%88%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本系列文章从零开始介绍C++模版元编程，需要有C++基础。</p>
<span id="more"></span>

<h3 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T <span class="type">const</span> a, T <span class="type">const</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">add</span>(<span class="number">42</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">add</span>&lt;<span class="type">double</span>&gt;(<span class="number">41.0</span>, <span class="number">21</span>); <span class="comment">// 无法自动推导类型的时候可以显示的指定类型</span></span><br></pre></td></tr></table></figure>



<h3 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">wrapper</span>(T <span class="type">const</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">  <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">wrapper <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 模版参数推导</span></span><br><span class="line"><span class="function">wrapper&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="成员函数模版"><a href="#成员函数模版" class="headerlink" title="成员函数模版"></a>成员函数模版</h3><h4 id="模版类的成员函数"><a href="#模版类的成员函数" class="headerlink" title="模版类的成员函数"></a>模版类的成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comoosition</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">T <span class="title">add</span><span class="params">(T <span class="type">const</span> a, T <span class="type">const</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">composition&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">c.<span class="built_in">add</span>(<span class="number">12</span>,<span class="number">32</span>);</span><br></pre></td></tr></table></figure>

<h4 id="非模版类的成员函数模版"><a href="#非模版类的成员函数模版" class="headerlink" title="非模版类的成员函数模版"></a>非模版类的成员函数模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">compotion</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">add</span><span class="params">(T <span class="type">const</span> a, T <span class="type">const</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">compostion c;</span><br><span class="line">c.<span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>,<span class="number">13</span>);</span><br><span class="line">c.<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="类模版的成员函数模版"><a href="#类模版的成员函数模版" class="headerlink" title="类模版的成员函数模版"></a>类模版的成员函数模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span> &#123;</span><br><span class="line">pbulic:</span><br><span class="line">  <span class="built_in">wrapper</span>(T <span class="type">const</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">  <span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function">U <span class="title">as</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U&gt;(value);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数模板的模板形参必须与类模板的模板形参不同</span></span><br><span class="line"></span><br><span class="line"><span class="function">wrapper&lt;<span class="type">double</span>&gt; <span class="title">a</span><span class="params">(<span class="number">42.1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> d = a.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">auto</span> b = a.<span class="built_in">as</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="模版参数"><a href="#模版参数" class="headerlink" title="模版参数"></a>模版参数</h3><h4 id="类型模版参数"><a href="#类型模版参数" class="headerlink" title="类型模版参数"></a>类型模版参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 不带默认参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; <span class="comment">// 带默认参数</span></span><br><span class="line"><span class="keyword">class</span> wrapper &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="comment">// 可变参数模版</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wrapper</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="非类型模版"><a href="#非类型模版" class="headerlink" title="非类型模版"></a>非类型模版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> V = <span class="number">42</span>&gt;</span><br><span class="line"><span class="keyword">class</span> foo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... V&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> S&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buffer</span> &#123;</span><br><span class="line">  T data_[S];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> T <span class="type">const</span> * <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> <span class="type">const</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> data_[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constexpr</span> T <span class="type">const</span>&amp; <span class="keyword">operator</span>[] (<span class="type">size_t</span> <span class="type">const</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data_[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">buffer&lt;<span class="type">int</span>, <span class="number">10</span>&gt; b1; </span><br><span class="line">buffer&lt;<span class="type">int</span>, <span class="number">2</span>*<span class="number">5</span>&gt; b2;</span><br></pre></td></tr></table></figure>

<p>看一种更常见的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">device</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">output</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">device</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="built_in">void</span> (*action) ()&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">smart_device</span> : device &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    (*action) ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_in_english</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> w1 = std::make_unique&lt;smart_device&lt;&amp;say_hello_in_english&gt;&gt;();</span><br><span class="line">w1-&gt;<span class="built_in">output</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双重模版参数"><a href="#双重模版参数" class="headerlink" title="双重模版参数"></a>双重模版参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T value; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fancy_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">fancy_wrapper</span>(T <span class="type">const</span> v) :<span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function">T <span class="type">const</span>&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function">U <span class="title">as</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;U&gt;(value); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> W = fancy_wrapper&gt;</span><br><span class="line"><span class="keyword">class</span> wrapping_pair &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">wrapping_pair</span>(T <span class="type">const</span> a, U <span class="type">const</span> b) : <span class="built_in">item1</span>(a), <span class="built_in">item2</span>(b) &#123; &#125;</span><br><span class="line">	W&lt;T&gt; item1;</span><br><span class="line">  W&lt;U&gt; item2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="默认模版参数"><a href="#默认模版参数" class="headerlink" title="默认模版参数"></a>默认模版参数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> foo &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">typename</span> U = <span class="type">double</span>&gt; </span><br><span class="line"><span class="keyword">class</span> bar &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="keyword">class</span> bar &#123; &#125;; <span class="comment">// error, 类模版带默认参数的参数，后面不能跟不带默认参数的参数。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>() &#123;&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; <span class="comment">// error redefinition // of default parameter</span></span><br><span class="line"><span class="keyword">struct</span> foo &#123;&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="模版实例化"><a href="#模版实例化" class="headerlink" title="模版实例化"></a>模版实例化</h3><p>模版实例化可以是显式的也可以是隐式的。</p>
<h4 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	foo&lt;<span class="type">int</span>&gt; *x; <span class="comment">// 不会实例化</span></span><br><span class="line">  foo&lt;<span class="type">int</span>&gt; p;  <span class="comment">// 会</span></span><br><span class="line">  foo&lt;<span class="type">int</span>&gt; p1; <span class="comment">// 会</span></span><br><span class="line">  foo&lt;<span class="type">double</span>&gt; *q; <span class="comment">// 不会</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  <span class="type">static</span> T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T foo&lt;T&gt;::data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  foo&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">  foo&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">  foo&lt;<span class="type">double</span>&gt; c;</span><br><span class="line">  std::cout &lt;&lt; a.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0 </span></span><br><span class="line">  std::cout &lt;&lt; b.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0 </span></span><br><span class="line">  std::cout &lt;&lt; c.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0</span></span><br><span class="line">  </span><br><span class="line">  b.data = <span class="number">42</span>;</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; a.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0 </span></span><br><span class="line">  std::cout &lt;&lt; b.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 42 </span></span><br><span class="line">  std::cout &lt;&lt; c.data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><p>显示实例化分为显示实例化定义和显示实例化声明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模版</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span>-key <span class="keyword">template</span>-name &lt;argument-list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">return</span>-type <span class="built_in">name</span>&lt;argument-list&gt; (parameter-list);</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">return</span>-type <span class="built_in">name</span>(parameter-list);</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">wrapper</span> &#123;</span><br><span class="line">    T value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">wrapper</span>&lt;<span class="type">int</span>&gt;; <span class="comment">// 显示实例化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">struct</span> <span class="title class_">ns</span>::wrapper&lt;<span class="type">double</span>&gt;; <span class="comment">// 显示实例化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T <span class="title">add</span><span class="params">(T <span class="type">const</span> a, T <span class="type">const</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">double</span> <span class="title">ns::add</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>







<h3 id="模版特化"><a href="#模版特化" class="headerlink" title="模版特化"></a>模版特化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floatiog_point</span> &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span> &lt;<span class="type">double</span>&gt;&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_floating_point</span> &lt;<span class="type">long</span> <span class="type">double</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="变量模版"><a href="#变量模版" class="headerlink" title="变量模版"></a>变量模版</h3><h3 id="别名模版"><a href="#别名模版" class="headerlink" title="别名模版"></a>别名模版</h3><h3 id="lambda-模版"><a href="#lambda-模版" class="headerlink" title="lambda 模版"></a>lambda 模版</h3>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入C++虚函数</title>
    <url>/2023/01/31/3-c++/template/</url>
    <content><![CDATA[<span id="more"></span>

]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <url>/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/template/</url>
    <content><![CDATA[<span id="more"></span>







]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/13/4-go/go%20channel/</url>
    <content><![CDATA[<h2 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h2><p>创建一个channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>



<h2 id="有缓冲"><a href="#有缓冲" class="headerlink" title="有缓冲"></a>有缓冲</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h2 id="通道方向"><a href="#通道方向" class="headerlink" title="通道方向"></a>通道方向</h2><p>指定channel的方向</p>
<h2 id="通道选择器"><a href="#通道选择器" class="headerlink" title="通道选择器"></a>通道选择器</h2><p>select </p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>default</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>time</p>
<h2 id="通道关闭"><a href="#通道关闭" class="headerlink" title="通道关闭"></a>通道关闭</h2><p>close ，</p>
<p>可以接收关闭channel的数据，但是不能向关闭的channel发送数据</p>
<h2 id="通道遍历"><a href="#通道遍历" class="headerlink" title="通道遍历"></a>通道遍历</h2><p>for range 会阻塞</p>
<h2 id="Timer-和-ticker"><a href="#Timer-和-ticker" class="headerlink" title="Timer 和 ticker"></a>Timer 和 ticker</h2><p>timer 可以再到期之前结束</p>
<p>ticker 时隔一定时间执行一次。</p>
<h2 id="通道的实现"><a href="#通道的实现" class="headerlink" title="通道的实现"></a>通道的实现</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/13/4-go/go%20context/</url>
    <content><![CDATA[<p>原文 <a href="https://go.dev/blog/context">https://go.dev/blog/context</a></p>
<p><a href="https://go.dev/blog/pipelines">https://go.dev/blog/pipelines</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在 Go 服务器中，每个传入的请求都在其自己的 goroutine 中处理。 </p>
<p>请求处理程序通常会启动额外的 goroutine 来访问后台，比如数据库和 RPC 服务等。</p>
<p> 处理请求的 goroutines 集通常需要访问特定于请求的值，例如最终用户的身份、授权令牌和请求的截止日期。</p>
<p> 当请求被取消或超时时，所有处理该请求的 goroutines 都应该快速退出，以便系统可以回收它们正在使用的任何资源。</p>
<p>Google开发了一个<code>context</code>包，可以轻松地将请求范围的值、取消信号和截止日期跨 API 边界传递给处理请求所涉及的所有 goroutine。context包公开可用 。本文介绍了如何使用该包并提供了一个完整的工作示例。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Context carries a deadline, cancellation signal, and request-scoped values</span></span><br><span class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></span><br><span class="line"><span class="comment">// goroutines.</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done returns a channel that is closed when this Context is canceled</span></span><br><span class="line">    <span class="comment">// or times out.</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err indicates why this context was canceled, after the Done channel</span></span><br><span class="line">    <span class="comment">// is closed.</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>Done</code>方法返回一个通道，该通道充当代表运行的函数的取消信号<code>Context</code>：当通道关闭时，函数应该放弃它们的工作并返回。<code>Err</code>方法返回一个错误，指示<code>Context</code>取消的原因。</p>
<p>Context 没有 Cancel 方法，原因与 Done 通道是仅接收的原因相同：接收取消信号的函数通常不是发送信号的函数。 特别是，当父操作为子操作启动 goroutine 时，这些子操作不应该能够取消父操作。 相反，WithCancel 函数（如下所述）提供了一种取消新 Context 值的方法。</p>
<p>一个 Context 对于多个 goroutine 同时使用是安全的。 代码可以将单个 Context 传递给任意数量的 goroutine，并取消该 Context 以向所有 goroutine 发出信号。</p>
<p>Deadline 方法允许函数确定它们是否应该开始工作； 如果剩下的时间太少，可能就不值得了。 代码也可以使用最后期限来设置 I&#x2F;O 操作的超时。</p>
<p>Value 允许上下文携带请求范围的数据。 该数据必须是安全的，以便多个 goroutine 同时使用。</p>
<h3 id="Derived-contexts"><a href="#Derived-contexts" class="headerlink" title="Derived contexts"></a>Derived contexts</h3><p>context 包提供了从现有值派生新 Context 值的函数。 这些值形成了一个树：当一个上下文被取消时，所有从它派生的上下文也被取消。</p>
<p>Background 是任何 Context 树的根； 它永远不会被取消：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Background returns an empty Context. It is never canceled, has no deadline,</span></span><br><span class="line"><span class="comment">// and has no values. Background is typically used in main, init, and tests,</span></span><br><span class="line"><span class="comment">// and as the top-level Context for incoming requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br></pre></td></tr></table></figure>

<p>WithCancel 和 WithTimeout 返回派生的 Context 值，这些值可以比父 Context 更快地取消。 当请求处理程序返回时，通常会取消与传入请求关联的上下文。 WithCancel 对于在使用多个副本时取消冗余请求也很有用。 WithTimeout 对于设置对后端服务器的请求的截止日期很有用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithCancel returns a copy of parent whose Done channel is closed as soon as</span></span><br><span class="line"><span class="comment">// parent.Done is closed or cancel is called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A CancelFunc cancels a Context.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout returns a copy of parent whose Done channel is closed as soon as</span></span><br><span class="line"><span class="comment">// parent.Done is closed, cancel is called, or timeout elapses. The new</span></span><br><span class="line"><span class="comment">// Context&#x27;s Deadline is the sooner of now+timeout and the parent&#x27;s deadline, if</span></span><br><span class="line"><span class="comment">// any. If the timer is still running, the cancel function releases its</span></span><br><span class="line"><span class="comment">// resources.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>

<p>WithValue 提供了一种将请求范围的值与 Context 相关联的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithValue returns a copy of parent whose Value method returns val for key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>我们的示例是一个 HTTP 服务器，它通过将查询“golang”转发到 Google Web Search API 并呈现结果来处理像 &#x2F;search?q&#x3D;golang&amp;timeout&#x3D;1s 这样的 URL。 timeout 参数告诉服务器在该持续时间过去后取消请求。</p>
<p>代码分为三个包：</p>
<p>server 为 &#x2F;search 提供主要功能和处理程序。<br>userip 提供了从请求中提取用户 IP 地址并将其与 Context 相关联的功能。<br>google 提供了用于向 Google 发送查询的搜索功能。</p>
<h3 id="The-server-program"><a href="#The-server-program" class="headerlink" title="The server program"></a>The server program</h3><p>server 通过为 golang 提供前几个 Google 搜索结果来处理像 &#x2F;search?q&#x3D;golang 这样的请求。 它注册 handleSearch 来处理 &#x2F;search 端点。 处理程序创建一个名为 ctx 的初始上下文，并安排在处理程序返回时取消它。 如果请求中包含 timeout URL 参数，则 Context 在超时后自动取消：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSearch</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ctx is the Context for this handler. Calling cancel closes the</span></span><br><span class="line">    <span class="comment">// ctx.Done channel, which is the cancellation signal for requests</span></span><br><span class="line">    <span class="comment">// started by this handler.</span></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        ctx    context.Context</span><br><span class="line">        cancel context.CancelFunc</span><br><span class="line">    )</span><br><span class="line">    timeout, err := time.ParseDuration(req.FormValue(<span class="string">&quot;timeout&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// The request has a timeout, so create a context that is</span></span><br><span class="line">        <span class="comment">// canceled automatically when the timeout expires.</span></span><br><span class="line">        ctx, cancel = context.WithTimeout(context.Background(), timeout)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx, cancel = context.WithCancel(context.Background())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// Cancel ctx as soon as handleSearch returns.</span></span><br></pre></td></tr></table></figure>

<p>处理程序从请求中提取查询，并通过调用 userip 包提取客户端的 IP 地址。 后端请求需要客户端的 IP 地址，因此 handleSearch 将其附加到 ctx：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check the search query.</span></span><br><span class="line">query := req.FormValue(<span class="string">&quot;q&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> query == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    http.Error(w, <span class="string">&quot;no query&quot;</span>, http.StatusBadRequest)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the user IP in ctx for use by code in other packages.</span></span><br><span class="line">userIP, err := userip.FromRequest(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = userip.NewContext(ctx, userIP)</span><br></pre></td></tr></table></figure>

<p>The handler calls <code>google.Search</code> with <code>ctx</code> and the <code>query</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run the Google search and print the results.</span></span><br><span class="line">start := time.Now()</span><br><span class="line">results, err := google.Search(ctx, query)</span><br><span class="line">elapsed := time.Since(start)</span><br></pre></td></tr></table></figure>

<p>If the search succeeds, the handler renders the results:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := resultsTemplate.Execute(w, <span class="keyword">struct</span> &#123;</span><br><span class="line">    Results          google.Results</span><br><span class="line">    Timeout, Elapsed time.Duration</span><br><span class="line">&#125;&#123;</span><br><span class="line">    Results: results,</span><br><span class="line">    Timeout: timeout,</span><br><span class="line">    Elapsed: elapsed,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Print(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Package-userip"><a href="#Package-userip" class="headerlink" title="Package userip"></a>Package userip</h3><p>userip 包提供了从请求中提取用户 IP 地址并将其与上下文相关联的功能。 上下文提供键值映射，其中键和值都是 interface{} 类型。 键类型必须支持相等，并且值必须安全地被多个 goroutine 同时使用。 像 userip 这样的包隐藏了这个映射的细节，并提供了对特定上下文值的强类型访问。</p>
<p>为了避免键冲突，userip 定义了一个未导出的类型键，并使用此类型的值作为上下文键：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The key type is unexported to prevent collisions with context keys defined in</span></span><br><span class="line"><span class="comment">// other packages.</span></span><br><span class="line"><span class="keyword">type</span> key <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// userIPkey is the context key for the user IP address.  Its value of zero is</span></span><br><span class="line"><span class="comment">// arbitrary.  If this package defined other context keys, they would have</span></span><br><span class="line"><span class="comment">// different integer values.</span></span><br><span class="line"><span class="keyword">const</span> userIPKey key = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>FromRequest 从 http.Request 中提取 userIP 值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromRequest</span><span class="params">(req *http.Request)</span></span> (net.IP, <span class="type">error</span>) &#123;</span><br><span class="line">    ip, _, err := net.SplitHostPort(req.RemoteAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;userip: %q is not IP:port&quot;</span>, req.RemoteAddr)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>NewContext 返回一个带有提供的 userIP 值的新 Context：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(ctx context.Context, userIP net.IP)</span></span> context.Context &#123;</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(ctx, userIPKey, userIP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FromContext 从 Context 中提取用户 IP：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromContext</span><span class="params">(ctx context.Context)</span></span> (net.IP, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// ctx.Value returns nil if ctx has no value for the key;</span></span><br><span class="line">    <span class="comment">// the net.IP type assertion returns ok=false for nil.</span></span><br><span class="line">    userIP, ok := ctx.Value(userIPKey).(net.IP)</span><br><span class="line">    <span class="keyword">return</span> userIP, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Package-google"><a href="#Package-google" class="headerlink" title="Package google"></a>Package google</h3><p>google.Search 函数向 Google Web Search API 发出 HTTP 请求并解析 JSON 编码的结果。 它接受 Context 参数 ctx 并在请求运行时如果 ctx.Done 关闭则立即返回。</p>
<p>Google Web Search API 请求包括搜索查询和用户 IP 作为查询参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(ctx context.Context, query <span class="type">string</span>)</span></span> (Results, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Prepare the Google Search API request.</span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://ajax.googleapis.com/ajax/services/search/web?v=1.0&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    q := req.URL.Query()</span><br><span class="line">    q.Set(<span class="string">&quot;q&quot;</span>, query)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If ctx is carrying the user IP address, forward it to the server.</span></span><br><span class="line">    <span class="comment">// Google APIs use the user IP to distinguish server-initiated requests</span></span><br><span class="line">    <span class="comment">// from end-user requests.</span></span><br><span class="line">    <span class="keyword">if</span> userIP, ok := userip.FromContext(ctx); ok &#123;</span><br><span class="line">        q.Set(<span class="string">&quot;userip&quot;</span>, userIP.String())</span><br><span class="line">    &#125;</span><br><span class="line">    req.URL.RawQuery = q.Encode()</span><br></pre></td></tr></table></figure>

<p>Search 使用辅助函数 httpDo 来发出 HTTP 请求，如果在处理请求或响应时 ctx.Done 关闭，则将其取消。 搜索传递一个闭包给 httpDo 处理 HTTP 响应：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results Results</span><br><span class="line">err = httpDo(ctx, req, <span class="function"><span class="keyword">func</span><span class="params">(resp *http.Response, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the JSON search result.</span></span><br><span class="line">    <span class="comment">// https://developers.google.com/web-search/docs/#fonje</span></span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">        ResponseData <span class="keyword">struct</span> &#123;</span><br><span class="line">            Results []<span class="keyword">struct</span> &#123;</span><br><span class="line">                TitleNoFormatting <span class="type">string</span></span><br><span class="line">                URL               <span class="type">string</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, res := <span class="keyword">range</span> data.ResponseData.Results &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, Result&#123;Title: res.TitleNoFormatting, URL: res.URL&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// httpDo waits for the closure we provided to return, so it&#x27;s safe to</span></span><br><span class="line"><span class="comment">// read results here.</span></span><br><span class="line"><span class="keyword">return</span> results, err</span><br></pre></td></tr></table></figure>

<p>httpDo 函数运行 HTTP 请求并在新的 goroutine 中处理其响应。 如果 ctx.Done 在 goroutine 退出之前关闭，它将取消请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpDo</span><span class="params">(ctx context.Context, req *http.Request, f <span class="keyword">func</span>(*http.Response, <span class="type">error</span>)</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// Run the HTTP request in a goroutine and pass the response to f.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- f(http.DefaultClient.Do(req)) &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        &lt;-c <span class="comment">// Wait for f to return.</span></span><br><span class="line">        <span class="keyword">return</span> ctx.Err()</span><br><span class="line">    <span class="keyword">case</span> err := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Adapting-code-for-Contexts"><a href="#Adapting-code-for-Contexts" class="headerlink" title="Adapting code for Contexts"></a>Adapting code for Contexts</h2><p>许多服务器框架提供包和类型来承载请求范围的值。 我们可以定义 Context 接口的新实现，以在使用现有框架的代码和需要 Context 参数的代码之间架起一座桥梁。</p>
<p>例如，Gorilla 的 <a href="http://www.gorillatoolkit.org/pkg/context">github.com&#x2F;gorilla&#x2F;context</a>  包允许处理程序通过提供从 HTTP 请求到键值对的映射来将数据与传入请求相关联。 在 gorilla.go 中，我们提供了一个 Context 实现，其 Value 方法返回与 Gorilla 包中特定 HTTP 请求关联的值。</p>
<p>其他包提供了类似于 Context 的取消支持。 例如，Tomb 提供了一个 Kill 方法，该方法通过关闭 Dying 通道来发出取消信号。 Tomb 还提供了等待这些 goroutine 退出的方法，类似于 sync.WaitGroup。 在 tomb.go 中，我们提供了一个 Context 实现，当它的父 Context 被取消或提供的 Tomb 被杀死时，该实现被取消。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在 Google，我们要求 Go 程序员将 Context 参数作为第一个参数传递给传入和传出请求之间调用路径上的每个函数。 这使得许多不同团队开发的 Go 代码能够很好地互操作。 它提供了对超时和取消的简单控制，并确保安全凭证等关键值正确传输 Go 程序。</p>
<p>想要在 Context 上构建的服务器框架应该提供 Context 的实现，以便在它们的包和那些需要 Context 参数的包之间架起一座桥梁。 然后，他们的客户端库将接受来自调用代码的上下文。 通过为请求范围的数据和取消建立一个通用接口，Context 使包开发人员更容易共享代码以创建可扩展的服务。</p>
]]></content>
  </entry>
  <entry>
    <title>go 闭包现象和原理</title>
    <url>/2023/01/31/4-go/go%20%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><span id="more"></span>

<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/13/4-go/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>深入C++虚函数</title>
    <url>/2023/01/31/3-c++/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>我一直认为 c++ 的精髓是 虚函数。</p>
<p>虚函数是运行时多状的基础。</p>
<p>今天就来扒一扒虚函数的内部机制。</p>
<span id="more"></span>

<h3 id="没有虚函数"><a href="#没有虚函数" class="headerlink" title="没有虚函数"></a>没有虚函数</h3><p>我们从 内存 来看 虚函数的 底层机制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_1;</span><br><span class="line">    <span class="type">int</span> base_2;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果很明显， 不需要多说什么。</span></span><br></pre></td></tr></table></figure>

<h3 id="只有一个虚函数"><a href="#只有一个虚函数" class="headerlink" title="只有一个虚函数"></a>只有一个虚函数</h3><p>接下来，我们看一下，带虚函数的对象的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_1;</span><br><span class="line">    <span class="type">int</span> base_2;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出来，对象前面多了八个字节。让我们来看看多了的是什么。</p>
<p>其实我们都知道，虚函数是在一个虚函数表里面。那么我们看看对象 b 的布局。</p>
<p>可以看到里面有个 指针，我们把里面的值打出来，看到是 一个函数指针，指向了 func()。</p>
<p>新定义一个变量 b1，查看 b1 的虚函数表，和内容，可以看到跟 b 是一摸一样的。说明一个类，只有一个虚函数表。</p>
<p>![image-20230605165441623](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230605165441623.png)</p>
<h3 id="多个虚函数"><a href="#多个虚函数" class="headerlink" title="多个虚函数"></a>多个虚函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_1;</span><br><span class="line">    <span class="type">int</span> base_2;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 16</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 8</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可以看到，对象对大小不变， 虚函数表里多了 func1。</p>
<p>![image-20230605170310030](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230605170310030.png)</p>
<h3 id="单继承且本身不存在虚函数"><a href="#单继承且本身不存在虚函数" class="headerlink" title="单继承且本身不存在虚函数"></a>单继承且本身不存在虚函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base_1;</span><br><span class="line">    <span class="type">int</span> base_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive_1;</span><br><span class="line">    <span class="type">int</span> derive_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Base b1; </span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">offsetof</span>(Base, base_2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Derive d;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>直接看内存， 虚函数表的地址不一样，但是指向了相同的函数。</p>
<p>![image-20230605172826693](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230605172826693.png)</p>
<h3 id="本身不存在虚函数但存在基类虚函数覆盖"><a href="#本身不存在虚函数但存在基类虚函数覆盖" class="headerlink" title="本身不存在虚函数但存在基类虚函数覆盖"></a>本身不存在虚函数但存在基类虚函数覆盖</h3>]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/13/4-go/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/13/4-go/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>oracle 层级查询</title>
    <url>/2023/02/01/2-%E6%95%B0%E6%8D%AE%E5%BA%93/2-oracle/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%2002-%E5%B1%82%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-Hierarchical-Queries"><a href="#1-Hierarchical-Queries" class="headerlink" title="1. Hierarchical Queries"></a>1. Hierarchical Queries</h2><p>如果嫌描述啰嗦，直接 看 例子<a href="#info"> prior 例子</a></p>
<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. <strong>语法</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> [nocycle] <span class="keyword">condition</span> [<span class="keyword">start</span> <span class="keyword">with</span> <span class="keyword">condition</span>]</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="keyword">condition</span> <span class="keyword">connect</span> <span class="keyword">by</span> [nocycle] <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>condition</code> </p>
<p><code>start with</code> 指定层次查询的 root row</p>
<p><code>connect by</code> 指定层次查询中 parent rows 和 child rows 的关系</p>
<ul>
<li>NOCYCLE 参数指示 Oracle 数据库从查询中返回行，即使数据中存在 CONNECT BY 循环。 将此参数与 CONNECT_BY_ISCYCLE 伪列一起使用以查看哪些行包含循环。 有关详细信息，请参阅 CONNECT_BY_ISCYCLE 伪列。</li>
<li>在分层查询中，条件中的一个表达式必须使用 PRIOR 运算符限定以引用父行。 例如，</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... PRIOR expr <span class="operator">=</span> expr</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">... expr <span class="operator">=</span> PRIOR expr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 CONNECT BY 条件是复合条件，则只有一个条件需要 PRIOR 运算符，尽管您可以有多个 PRIOR 条件。 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> last_name <span class="operator">!=</span> <span class="string">&#x27;King&#x27;</span> <span class="keyword">AND</span> PRIOR employee_id <span class="operator">=</span> manager_id ...</span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id <span class="keyword">and</span> </span><br><span class="line">           PRIOR account_mgr_id <span class="operator">=</span> customer_id ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PRIOR 是一元运算符，与一元 + 和 - 算术运算符具有相同的优先级。 它为分层查询中当前行的父行计算紧随其后的表达式。</p>
<p>PRIOR 最常用于使用相等运算符比较列值时。 （PRIOR 关键字可以在运算符的任一侧。） PRIOR 使 Oracle 使用列中父行的值。 在 CONNECT BY 子句中理论上可以使用除等号 (&#x3D;) 以外的运算符。 但是，这些其他运算符创建的条件可能会导致通过可能的组合的无限循环。 在这种情况下，Oracle 在运行时检测到循环并返回错误。</p>
<p>CONNECT BY 条件和 PRIOR 表达式都可以采用不相关子查询的形式。 但是，CURRVAL 和 NEXTVAL 不是有效的 PRIOR 表达式，因此 PRIOR 表达式不能引用序列。</p>
<p>您可以通过使用 CONNECT_BY_ROOT 运算符来进一步细化层次查询，以限定选择列表中的列。 此运算符不仅返回直接父行，而且返回层次结构中的所有祖先行，从而扩展了层次查询的 CONNECT BY [PRIOR] 条件的功能。</p>
<h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2. 执行过程"></a>2. 执行过程</h3><p>Oracle 按如下方式处理分层查询：</p>
<ul>
<li>如果存在连接，则首先评估连接，无论连接是在 FROM 子句中指定还是使用 WHERE 子句谓词。</li>
<li>评估 CONNECT BY 条件。</li>
<li>评估任何剩余的 WHERE 子句谓词。</li>
</ul>
<p>然后，Oracle 使用来自这些评估的信息通过以下步骤形成层次结构：</p>
<ol>
<li>Oracle 选择层次结构的根行——那些满足 START WITH 条件的行。</li>
<li>Oracle 选择每个根行的子行。每个子行必须满足关于其中一个根行的 CONNECT BY 条件的条件。</li>
<li>Oracle 选择连续几代的子行。 Oracle 首先选择步骤 2 中返回的行的子代，然后选择这些子代的子代，以此类推。 Oracle 总是通过评估与当前父行相关的 CONNECT BY 条件来选择子行。</li>
<li>如果查询包含没有连接的 WHERE 子句，则 Oracle 从层次结构中删除所有不满足 WHERE 子句条件的行。 Oracle 对每一行单独评估此条件，而不是删除不满足条件的行的所有子行。</li>
<li>Oracle 按图 9-1 所示的顺序返回行。在图中，孩子出现在父母的下方。有关分层树的说明，请参见图 3-1。</li>
</ol>
<p><img src="https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/img/sqlrf002.gif" alt="Description of Figure 9-1 follows"></p>
<p>为了找到父行的子行，Oracle 计算父行的 CONNECT BY 条件的 PRIOR 表达式和表中每一行的另一个表达式。 条件为真的行是父项的子项。 CONNECT BY 条件可以包含其他条件以进一步过滤查询选择的行。</p>
<p>如果 CONNECT BY 条件导致层次结构中出现循环，则 Oracle 返回错误。 如果一行既是另一行的父（或祖父母或直接祖先）又是子（或孙子或直接后代），则发生循环。</p>
<blockquote>
<p>注意：在分层查询中，不要指定 ORDER BY 或 GROUP BY，因为它们会覆盖 CONNECT BY 结果的分层顺序。 如果要对同一父级的兄弟行进行排序，请使用 ORDER SIBLINGS BY 子句。 请参见 order_by_clause。</p>
</blockquote>
<h3 id="3-Hierarchical-例子"><a href="#3-Hierarchical-例子" class="headerlink" title="3. Hierarchical  例子"></a>3. Hierarchical  例子</h3><h4 id="3-1CONNECT-BY-Example"><a href="#3-1CONNECT-BY-Example" class="headerlink" title="3.1CONNECT BY Example"></a>3.1<strong>CONNECT BY Example</strong></h4><p>以下分层查询使用 CONNECT BY 子句来定义员工和经理之间的关系：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, manager_id</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id;</span><br><span class="line"></span><br><span class="line">EMPLOYEE_ID LAST_NAME                 MANAGER_ID</span><br><span class="line"><span class="comment">----------- ------------------------- ----------</span></span><br><span class="line">        <span class="number">101</span> Kochhar                          <span class="number">100</span></span><br><span class="line">        <span class="number">108</span> Greenberg                        <span class="number">101</span></span><br><span class="line">        <span class="number">109</span> Faviet                           <span class="number">108</span></span><br><span class="line">        <span class="number">110</span> Chen                             <span class="number">108</span></span><br><span class="line">        <span class="number">111</span> Sciarra                          <span class="number">108</span></span><br><span class="line">        <span class="number">112</span> Urman                            <span class="number">108</span></span><br><span class="line">        <span class="number">113</span> Popp                             <span class="number">108</span></span><br><span class="line">        <span class="number">200</span> Whalen                           <span class="number">101</span></span><br><span class="line">        <span class="number">203</span> Mavris                           <span class="number">101</span></span><br><span class="line">        <span class="number">204</span> Baer                             <span class="number">101</span></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<h4 id="3-2-LEVEL-Example"><a href="#3-2-LEVEL-Example" class="headerlink" title="3.2 LEVEL Example"></a>3.2 <strong>LEVEL Example</strong></h4><p>下一个示例与前面的示例类似，但使用 LEVEL 伪列来显示父行和子行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, manager_id, LEVEL</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id;</span><br><span class="line"></span><br><span class="line">EMPLOYEE_ID LAST_NAME                 MANAGER_ID      LEVEL</span><br><span class="line"><span class="comment">----------- ------------------------- ---------- ----------</span></span><br><span class="line">        <span class="number">101</span> Kochhar                          <span class="number">100</span>          <span class="number">1</span></span><br><span class="line">        <span class="number">108</span> Greenberg                        <span class="number">101</span>          <span class="number">2</span></span><br><span class="line">        <span class="number">109</span> Faviet                           <span class="number">108</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">110</span> Chen                             <span class="number">108</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">111</span> Sciarra                          <span class="number">108</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">112</span> Urman                            <span class="number">108</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">113</span> Popp                             <span class="number">108</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">200</span> Whalen                           <span class="number">101</span>          <span class="number">2</span></span><br><span class="line">        <span class="number">203</span> Mavris                           <span class="number">101</span>          <span class="number">2</span></span><br><span class="line">        <span class="number">204</span> Baer                             <span class="number">101</span>          <span class="number">2</span></span><br><span class="line">        <span class="number">205</span> Higgins                          <span class="number">101</span>          <span class="number">2</span></span><br><span class="line">        <span class="number">206</span> Gietz                            <span class="number">205</span>          <span class="number">3</span></span><br><span class="line">        <span class="number">102</span> De Haan                          <span class="number">100</span>          <span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="3-3-START-WITH-Examples"><a href="#3-3-START-WITH-Examples" class="headerlink" title="3.3 START WITH Examples"></a>3.3 <strong>START WITH Examples</strong></h4><p>下一个示例添加一个 START WITH 子句来指定层次结构的根行，并使用 SIBLINGS 关键字添加一个 ORDER BY 子句来保持层次结构内的顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, employee_id, manager_id, LEVEL</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">START</span> <span class="keyword">WITH</span> employee_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">      <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id</span><br><span class="line">      <span class="keyword">ORDER</span> SIBLINGS <span class="keyword">BY</span> last_name;</span><br><span class="line"></span><br><span class="line">LAST_NAME                 EMPLOYEE_ID MANAGER_ID      LEVEL</span><br><span class="line"><span class="comment">------------------------- ----------- ---------- ----------</span></span><br><span class="line">King                              <span class="number">100</span>                     <span class="number">1</span></span><br><span class="line">Cambrault                         <span class="number">148</span>        <span class="number">100</span>          <span class="number">2</span></span><br><span class="line">Bates                             <span class="number">172</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">Bloom                             <span class="number">169</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">Fox                               <span class="number">170</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">Kumar                             <span class="number">173</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">Ozer                              <span class="number">168</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">Smith                             <span class="number">171</span>        <span class="number">148</span>          <span class="number">3</span></span><br><span class="line">De Haan                           <span class="number">102</span>        <span class="number">100</span>          <span class="number">2</span></span><br><span class="line">Hunold                            <span class="number">103</span>        <span class="number">102</span>          <span class="number">3</span></span><br><span class="line">Austin                            <span class="number">105</span>        <span class="number">103</span>          <span class="number">4</span></span><br><span class="line">Ernst                             <span class="number">104</span>        <span class="number">103</span>          <span class="number">4</span></span><br><span class="line">Lorentz                           <span class="number">107</span>        <span class="number">103</span>          <span class="number">4</span></span><br><span class="line">Pataballa                         <span class="number">106</span>        <span class="number">103</span>          <span class="number">4</span></span><br><span class="line">Errazuriz                         <span class="number">147</span>        <span class="number">100</span>          <span class="number">2</span></span><br><span class="line">Ande                              <span class="number">166</span>        <span class="number">147</span>          <span class="number">3</span></span><br><span class="line">Banda                             <span class="number">167</span>        <span class="number">147</span>          <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 hr.employees 表中，员工 Steven King 是公司的负责人，没有经理。 他的员工中有 John Russell，他是部门 80 的经理。如果您更新 employees 表以将 Russell 设置为 King 的经理，您会在数据中创建一个循环：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> manager_id <span class="operator">=</span> <span class="number">145</span></span><br><span class="line">   <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name &quot;Employee&quot;, </span><br><span class="line">   LEVEL, SYS_CONNECT_BY_PATH(last_name, <span class="string">&#x27;/&#x27;</span>) &quot;Path&quot;</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">WHERE</span> level <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">AND</span> department_id <span class="operator">=</span> <span class="number">80</span></span><br><span class="line">   <span class="keyword">START</span> <span class="keyword">WITH</span> last_name <span class="operator">=</span> <span class="string">&#x27;King&#x27;</span></span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id <span class="keyword">AND</span> LEVEL <span class="operator">&lt;=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">ORA<span class="number">-01436</span>: <span class="keyword">CONNECT</span> <span class="keyword">BY</span> loop <span class="keyword">in</span> <span class="keyword">user</span> data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CONNECT BY 条件中的 NOCYCLE 参数使 Oracle 尽管有循环仍返回行。 CONNECT_BY_ISCYCLE 伪列显示哪些行包含循环：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name &quot;Employee&quot;, CONNECT_BY_ISCYCLE &quot;Cycle&quot;,</span><br><span class="line">   LEVEL, SYS_CONNECT_BY_PATH(last_name, <span class="string">&#x27;/&#x27;</span>) &quot;Path&quot;</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">WHERE</span> level <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">AND</span> department_id <span class="operator">=</span> <span class="number">80</span></span><br><span class="line">   <span class="keyword">START</span> <span class="keyword">WITH</span> last_name <span class="operator">=</span> <span class="string">&#x27;King&#x27;</span></span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> NOCYCLE PRIOR employee_id <span class="operator">=</span> manager_id <span class="keyword">AND</span> LEVEL <span class="operator">&lt;=</span> <span class="number">4</span></span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> &quot;Employee&quot;, &quot;Cycle&quot;, LEVEL, &quot;Path&quot;;</span><br><span class="line"></span><br><span class="line">Employee                       <span class="keyword">Cycle</span>      LEVEL Path</span><br><span class="line"><span class="comment">------------------------- ---------- ---------- -------------------------</span></span><br><span class="line">Abel                               <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Zlotkey<span class="operator">/</span>Abel</span><br><span class="line">Ande                               <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz<span class="operator">/</span>Ande</span><br><span class="line">Banda                              <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz<span class="operator">/</span>Banda</span><br><span class="line">Bates                              <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Bates</span><br><span class="line">Bernstein                          <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Russell<span class="operator">/</span>Bernstein</span><br><span class="line">Bloom                              <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Bloom</span><br><span class="line">Cambrault                          <span class="number">0</span>          <span class="number">2</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault</span><br><span class="line">Cambrault                          <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Russell<span class="operator">/</span>Cambrault</span><br><span class="line">Doran                              <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Partners<span class="operator">/</span>Doran</span><br><span class="line">Errazuriz                          <span class="number">0</span>          <span class="number">2</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz</span><br><span class="line">Fox                                <span class="number">0</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Fox</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="3-4-CONNECT-BY-ISLEAF-Example"><a href="#3-4-CONNECT-BY-ISLEAF-Example" class="headerlink" title="3.4 CONNECT_BY_ISLEAF Example"></a>3.4 <strong>CONNECT_BY_ISLEAF Example</strong></h4><p>以下语句显示了如何使用分层查询将列中的值转换为逗号分隔的列表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LTRIM(SYS_CONNECT_BY_PATH (warehouse_id,<span class="string">&#x27;,&#x27;</span>),<span class="string">&#x27;,&#x27;</span>) <span class="keyword">FROM</span></span><br><span class="line">   (<span class="keyword">SELECT</span> ROWNUM r, warehouse_id <span class="keyword">FROM</span> warehouses)</span><br><span class="line">   <span class="keyword">WHERE</span> CONNECT_BY_ISLEAF <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">START</span> <span class="keyword">WITH</span> r <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> r <span class="operator">=</span> PRIOR r <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> warehouse_id; </span><br><span class="line"> </span><br><span class="line">LTRIM(SYS_CONNECT_BY_PATH(WAREHOUSE_ID,<span class="string">&#x27;,&#x27;</span>),<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-CONNECT-BY-ROOT-Examples"><a href="#3-5-CONNECT-BY-ROOT-Examples" class="headerlink" title="3.5 CONNECT_BY_ROOT Examples"></a>3.5 <strong>CONNECT_BY_ROOT Examples</strong></h4><p>以下示例返回部门 110 中每个员工的姓氏、层次结构中该员工上方最高级别的每个经理、经理和员工之间的级别数以及两者之间的路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name &quot;Employee&quot;, CONNECT_BY_ROOT last_name &quot;Manager&quot;,</span><br><span class="line">   LEVEL<span class="number">-1</span> &quot;Pathlen&quot;, SYS_CONNECT_BY_PATH(last_name, <span class="string">&#x27;/&#x27;</span>) &quot;Path&quot;</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">WHERE</span> LEVEL <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">and</span> department_id <span class="operator">=</span> <span class="number">110</span></span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> &quot;Employee&quot;, &quot;Manager&quot;, &quot;Pathlen&quot;, &quot;Path&quot;;</span><br><span class="line"></span><br><span class="line">Employee        Manager            Pathlen Path</span><br><span class="line"><span class="comment">--------------- --------------- ---------- ------------------------------</span></span><br><span class="line">Gietz           Higgins                  <span class="number">1</span> <span class="operator">/</span>Higgins<span class="operator">/</span>Gietz</span><br><span class="line">Gietz           King                     <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins<span class="operator">/</span>Gietz</span><br><span class="line">Gietz           Kochhar                  <span class="number">2</span> <span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins<span class="operator">/</span>Gietz</span><br><span class="line">Higgins         King                     <span class="number">2</span> <span class="operator">/</span>King<span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins</span><br><span class="line">Higgins         Kochhar                  <span class="number">1</span> <span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以下示例使用 GROUP BY 子句返回部门 110 中每个员工的总工资以及层次结构中该员工之上的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">SUM</span>(salary) &quot;Total_Salary&quot; <span class="keyword">FROM</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> CONNECT_BY_ROOT last_name <span class="keyword">as</span> name, Salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">110</span></span><br><span class="line">      <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id)</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> name</span><br><span class="line">   <span class="keyword">ORDER</span> <span class="keyword">BY</span> name, &quot;Total_Salary&quot;;</span><br><span class="line"></span><br><span class="line">NAME                      Total_Salary</span><br><span class="line"><span class="comment">------------------------- ------------</span></span><br><span class="line">Gietz                             <span class="number">8300</span></span><br><span class="line">Higgins                          <span class="number">20300</span></span><br><span class="line">King                             <span class="number">20300</span></span><br><span class="line">Kochhar                          <span class="number">20300</span></span><br></pre></td></tr></table></figure>







<h2 id="2-Hierarchical-Operators"><a href="#2-Hierarchical-Operators" class="headerlink" title="2. Hierarchical  Operators"></a>2. Hierarchical  Operators</h2><p>两个运算符 PRIOR 和 CONNECT_BY_ROOT 仅在分层查询中有效</p>
<h3 id="1-PRIOR"><a href="#1-PRIOR" class="headerlink" title="1. PRIOR"></a>1. PRIOR</h3><p>在分层查询中，CONNECT BY 条件中的一个表达式必须由 PRIOR 运算符限定。 如果 CONNECT BY 条件是复合条件，则只有一个条件需要 PRIOR 运算符，尽管您可以有多个 PRIOR 条件。 PRIOR 计算层次查询中当前行的父行的紧随其后的表达式。</p>
<p>PRIOR 最常用于使用相等运算符比较列值时。 （PRIOR 关键字可以在运算符的任一侧。） PRIOR 使 Oracle 使用列中父行的值。 在 CONNECT BY 子句中理论上可以使用除等号 (&#x3D;) 以外的运算符。 但是，这些其他运算符创建的条件可能会导致通过可能的组合的无限循环。 在这种情况下，Oracle 在运行时检测到循环并返回错误。 有关此运算符的更多信息（包括示例），请参阅分层查询。</p>
<p>如果还不理解 prior，见后面的例子<a href="#info"> prior 例子</a></p>
<h3 id="2-CONNECT-BY-ROOT"><a href="#2-CONNECT-BY-ROOT" class="headerlink" title="2. CONNECT_BY_ROOT"></a>2. CONNECT_BY_ROOT</h3><p>CONNECT_BY_ROOT 是一元运算符，仅在分层查询中有效。 当您使用此运算符限定列时，Oracle 使用根行中的数据返回列值。 此运算符扩展了分层查询的 CONNECT BY [PRIOR] 条件的功能。</p>
<p>对 CONNECT_BY_ROOT 的限制</p>
<p>您不能在 START WITH 条件或 CONNECT BY 条件中指定此运算符。</p>
<h2 id="3-Hierarchical-伪列"><a href="#3-Hierarchical-伪列" class="headerlink" title="3. Hierarchical  伪列"></a>3. Hierarchical  伪列</h2><p>分层查询伪列仅 (Pseudocolumns) 在分层查询中有效。 分层查询伪列是：</p>
<ul>
<li>[CONNECT_BY_ISCYCLE Pseudocolumn]</li>
<li>[CONNECT_BY_ISLEAF Pseudocolumn]</li>
<li>[LEVEL Pseudocolumn]</li>
</ul>
<p>要在查询中定义层次关系，您必须使用 CONNECT BY 子句。</p>
<h3 id="3-1-CONNECT-BY-ISCYCLE"><a href="#3-1-CONNECT-BY-ISCYCLE" class="headerlink" title="3.1 CONNECT_BY_ISCYCLE"></a>3.1 CONNECT_BY_ISCYCLE</h3><p>如果当前行有一个也是其祖先的子项，则 CONNECT_BY_ISCYCLE 伪列返回 1。 否则返回 0。</p>
<p>仅当您已指定 CONNECT BY 子句的 NOCYCLE 参数时，您才能指定 CONNECT_BY_ISCYCLE。 NOCYCLE 使 Oracle 能够返回查询的结果，否则该查询会因数据中的 CONNECT BY 循环而失败。</p>
<h3 id="3-2-CONNECT-BY-ISLEAF"><a href="#3-2-CONNECT-BY-ISLEAF" class="headerlink" title="3.2 CONNECT_BY_ISLEAF"></a>3.2 CONNECT_BY_ISLEAF</h3><p>如果当前行是由 CONNECT BY 条件定义的树的叶子，则 CONNECT_BY_ISLEAF 伪列返回 1。 否则返回 0。此信息指示是否可以进一步扩展给定行以显示更多层次结构。</p>
<p><strong>CONNECT_BY_ISLEAF Example</strong></p>
<p>以下示例显示了 hr.employees 表的前三个级别，为每一行指示它是叶行（在 IsLeaf 列中用 1 表示）还是有子行（在 IsLeaf 列中用 0 表示）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name &quot;Employee&quot;, CONNECT_BY_ISLEAF &quot;IsLeaf&quot;,</span><br><span class="line">       LEVEL, SYS_CONNECT_BY_PATH(last_name, <span class="string">&#x27;/&#x27;</span>) &quot;Path&quot;</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> LEVEL <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">AND</span> department_id <span class="operator">=</span> <span class="number">80</span></span><br><span class="line">  <span class="keyword">START</span> <span class="keyword">WITH</span> employee_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id <span class="keyword">AND</span> LEVEL <span class="operator">&lt;=</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> &quot;Employee&quot;, &quot;IsLeaf&quot;;</span><br><span class="line"></span><br><span class="line">Employee                      IsLeaf      LEVEL Path</span><br><span class="line"><span class="comment">------------------------- ---------- ---------- -------------------------</span></span><br><span class="line">Abel                               <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Zlotkey<span class="operator">/</span>Abel</span><br><span class="line">Ande                               <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz<span class="operator">/</span>Ande</span><br><span class="line">Banda                              <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz<span class="operator">/</span>Banda</span><br><span class="line">Bates                              <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Bates</span><br><span class="line">Bernstein                          <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Russell<span class="operator">/</span>Bernstein</span><br><span class="line">Bloom                              <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Bloom</span><br><span class="line">Cambrault                          <span class="number">0</span>          <span class="number">2</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault</span><br><span class="line">Cambrault                          <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Russell<span class="operator">/</span>Cambrault</span><br><span class="line">Doran                              <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Partners<span class="operator">/</span>Doran</span><br><span class="line">Errazuriz                          <span class="number">0</span>          <span class="number">2</span> <span class="operator">/</span>King<span class="operator">/</span>Errazuriz</span><br><span class="line">Fox                                <span class="number">1</span>          <span class="number">3</span> <span class="operator">/</span>King<span class="operator">/</span>Cambrault<span class="operator">/</span>Fox</span><br><span class="line">. . . </span><br></pre></td></tr></table></figure>

<h3 id="3-3-LEVEL"><a href="#3-3-LEVEL" class="headerlink" title="3.3 LEVEL"></a>3.3 LEVEL</h3><p>对于分层查询返回的每一行，LEVEL 伪列为根行返回 1，为根的子行返回 2，依此类推。 根行是倒排树中的最高行。 子行是任何非根行。 父行是具有子行的任何行。 叶行是任何没有子行的行。 图 3-1 显示了倒排树的节点及其 LEVEL 值。</p>
<p><img src="https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/img/sqlrf001.gif" alt="Description of Figure 3-1 follows"></p>
<h2 id="4-SYS-CONNECT-BY-PATH"><a href="#4-SYS-CONNECT-BY-PATH" class="headerlink" title="4. SYS_CONNECT_BY_PATH"></a>4. SYS_CONNECT_BY_PATH</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SYS_CONNECT_BY_PATH (<span class="keyword">column</span>, <span class="type">char</span>) </span><br></pre></td></tr></table></figure>

<h3 id="4-1-功能"><a href="#4-1-功能" class="headerlink" title="4.1 功能"></a>4.1 功能</h3><p>SYS_CONNECT_BY_PATH 仅在分层查询中有效。 它返回列值从根到节点的路径，对于 CONNECT BY 条件返回的每一行，列值由 char 分隔。</p>
<p>column 和 char 都可以是任何数据类型 CHAR、VARCHAR2、NCHAR 或 NVARCHAR2。 返回的字符串是 VARCHAR2 数据类型，并且与列在同一字符集中。</p>
<h3 id="4-2-例子"><a href="#4-2-例子" class="headerlink" title="4.2 例子"></a>4.2 <strong>例子</strong></h3><p>以下示例返回从员工 Kochhar 到 Kochhar 的所有员工（及其员工）的员工姓名路径：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27; &#x27;</span>, <span class="number">2</span><span class="operator">*</span>level<span class="number">-1</span>)<span class="operator">||</span>SYS_CONNECT_BY_PATH(last_name, <span class="string">&#x27;/&#x27;</span>) &quot;Path&quot;</span><br><span class="line">   <span class="keyword">FROM</span> employees</span><br><span class="line">   <span class="keyword">START</span> <span class="keyword">WITH</span> last_name <span class="operator">=</span> <span class="string">&#x27;Kochhar&#x27;</span></span><br><span class="line">   <span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR employee_id <span class="operator">=</span> manager_id;</span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg<span class="operator">/</span>Chen</span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg<span class="operator">/</span>Faviet</span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg<span class="operator">/</span>Popp</span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg<span class="operator">/</span>Sciarra</span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg<span class="operator">/</span>Urman</span><br><span class="line">     <span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins<span class="operator">/</span>Gietz</span><br><span class="line">   <span class="operator">/</span>Kochhar<span class="operator">/</span>Baer</span><br><span class="line">   <span class="operator">/</span>Kochhar<span class="operator">/</span>Greenberg</span><br><span class="line">   <span class="operator">/</span>Kochhar<span class="operator">/</span>Higgins</span><br><span class="line">   <span class="operator">/</span>Kochhar<span class="operator">/</span>Mavris</span><br><span class="line">   <span class="operator">/</span>Kochhar<span class="operator">/</span>Whalen</span><br><span class="line"> <span class="operator">/</span>Kochhar</span><br></pre></td></tr></table></figure>



<h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5. 例子"></a>5. 例子</h2><h3 id="5-1-构造数据"><a href="#5-1-构造数据" class="headerlink" title="5.1 构造数据"></a>5.1 构造数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_tree (</span><br><span class="line">  test_id   <span class="type">INT</span>  <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  pid       <span class="type">INT</span>,</span><br><span class="line">  test_val  <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (test_id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">0</span>,   <span class="string">&#x27;.NET&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">1</span>,      <span class="string">&#x27;C#&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="number">1</span>,      <span class="string">&#x27;J#&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">1</span>,      <span class="string">&#x27;ASP.NET&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">1</span>,      <span class="string">&#x27;VB.NET&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">6</span>, <span class="number">0</span>,   <span class="string">&#x27;J2EE&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">7</span>, <span class="number">6</span>,      <span class="string">&#x27;EJB&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">8</span>, <span class="number">6</span>,      <span class="string">&#x27;Servlet&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">9</span>, <span class="number">6</span>,      <span class="string">&#x27;JSP&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">10</span>, <span class="number">0</span>,  <span class="string">&#x27;Database&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">11</span>, <span class="number">10</span>,    <span class="string">&#x27;DB2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">12</span>, <span class="number">10</span>,    <span class="string">&#x27;MySQL&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">13</span>, <span class="number">10</span>,    <span class="string">&#x27;Oracle&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">14</span>, <span class="number">10</span>,    <span class="string">&#x27;SQL Server&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">15</span>, <span class="number">13</span>,    <span class="string">&#x27;PL/SQL&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">16</span>, <span class="number">15</span>,    <span class="string">&#x27;Function&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">17</span>, <span class="number">15</span>,    <span class="string">&#x27;Procedure&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">18</span>, <span class="number">15</span>,    <span class="string">&#x27;Package&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">19</span>, <span class="number">15</span>,    <span class="string">&#x27;Cursor&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_tree <span class="keyword">VALUES</span>(<span class="number">20</span>, <span class="number">14</span>,    <span class="string">&#x27;T-SQL&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  LEVEL,</span><br><span class="line">  test_id,</span><br><span class="line">  test_val,</span><br><span class="line">  SYS_CONNECT_BY_PATH(test_val, <span class="string">&#x27;\&#x27;</span>) <span class="keyword">AS</span> &quot;FullPath&quot;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  test_tree</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span></span><br><span class="line">  pid <span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR test_id <span class="operator">=</span> pid</span><br><span class="line"><span class="keyword">ORDER</span> SIBLINGS <span class="keyword">BY</span> test_val;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-执行结果解释"><a href="#5-2-执行结果解释" class="headerlink" title="5.2 执行结果解释"></a>5.2 执行结果解释</h3><p> start with 配合 level 解释比较好理解，如果不指定 start with， 那么所有数据都会作为 根行，也就是 level 1。</p>
<p>如果指定了 start with ，被指定的行为根行。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不指定 start with</span></span><br><span class="line"><span class="keyword">SELECT</span>  level ,test_id, pid, test_val <span class="keyword">from</span> test_tree   <span class="keyword">CONNECT</span> <span class="keyword">BY</span>  prior test_id<span class="operator">=</span> pid </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">1</span>	  <span class="number">0</span> 	.NET</span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>  	<span class="number">1</span>  	C#</span><br><span class="line"><span class="number">1</span>	<span class="number">3</span>  	<span class="number">1</span>  	J#</span><br><span class="line"><span class="number">1</span>	<span class="number">4</span>	  <span class="number">1</span>  	ASP.NET</span><br><span class="line"><span class="number">1</span>	<span class="number">5</span>	  <span class="number">1</span>  	VB.NET</span><br><span class="line"><span class="number">1</span>	<span class="number">6</span>  	<span class="number">0</span>  	J2EE</span><br><span class="line"><span class="number">1</span>	<span class="number">7</span>	  <span class="number">6</span>  	EJB</span><br><span class="line"><span class="number">1</span>	<span class="number">8</span>	  <span class="number">6</span>  	Servlet</span><br><span class="line"><span class="number">1</span>	<span class="number">9</span>	  <span class="number">6</span>  	JSP</span><br><span class="line"><span class="number">1</span>	<span class="number">10</span>	<span class="number">0</span>	  Database</span><br><span class="line"><span class="number">1</span>	<span class="number">11</span>	<span class="number">10</span>	DB2</span><br><span class="line"><span class="number">1</span>	<span class="number">12</span>	<span class="number">10</span>	MySQL</span><br><span class="line"><span class="number">1</span>	<span class="number">13</span>	<span class="number">10</span>	Oracle</span><br><span class="line"><span class="number">1</span>	<span class="number">14</span>	<span class="number">10</span>	<span class="keyword">SQL</span> Server</span><br><span class="line"><span class="number">1</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">1</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">1</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">1</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">1</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br><span class="line"><span class="number">1</span>	<span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">2</span>	<span class="number">2</span>	  <span class="number">1</span>	  C#</span><br><span class="line"><span class="number">2</span>	<span class="number">3</span>  	<span class="number">1</span>	  J#</span><br><span class="line"><span class="number">2</span>	<span class="number">4</span>  	<span class="number">1</span>  	ASP.NET</span><br><span class="line"><span class="number">2</span>	<span class="number">5</span>  	<span class="number">1</span>  	VB.NET</span><br><span class="line"><span class="number">2</span>	<span class="number">7</span>	  <span class="number">6</span>  	EJB</span><br><span class="line"><span class="number">2</span>	<span class="number">8</span>	  <span class="number">6</span>  	Servlet</span><br><span class="line"><span class="number">2</span>	<span class="number">9</span>	  <span class="number">6</span>  	JSP</span><br><span class="line"><span class="number">2</span>	<span class="number">11</span>	<span class="number">10</span>	DB2</span><br><span class="line"><span class="number">2</span>	<span class="number">12</span>	<span class="number">10</span>	MySQL</span><br><span class="line"><span class="number">2</span>	<span class="number">13</span>	<span class="number">10</span>	Oracle</span><br><span class="line"><span class="number">2</span>	<span class="number">14</span>	<span class="number">10</span>	<span class="keyword">SQL</span> Server</span><br><span class="line"><span class="number">2</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">2</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">2</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">2</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">2</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br><span class="line"><span class="number">2</span>	<span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">3</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">3</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">3</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">3</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">3</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br><span class="line"><span class="number">3</span>	<span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">4</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">4</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">4</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">4</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定 start with</span></span><br><span class="line"><span class="keyword">SELECT</span>  level ,test_id, pid, test_val <span class="keyword">from</span> test_tree  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> test_id<span class="operator">=</span><span class="number">10</span> <span class="keyword">CONNECT</span> <span class="keyword">BY</span>  prior test_id<span class="operator">=</span> pid <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">10</span>	<span class="number">0</span>	  Database</span><br><span class="line"><span class="number">2</span>	<span class="number">11</span>	<span class="number">10</span>	DB2</span><br><span class="line"><span class="number">2</span>	<span class="number">12</span>	<span class="number">10</span>	MySQL</span><br><span class="line"><span class="number">2</span>	<span class="number">13</span>	<span class="number">10</span>	Oracle</span><br><span class="line"><span class="number">2</span>	<span class="number">14</span>	<span class="number">10</span>	<span class="keyword">SQL</span> Server</span><br><span class="line"><span class="number">3</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">3</span>	<span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">4</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">4</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">4</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">4</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br></pre></td></tr></table></figure>



<p><a id="info"> prior例子 </a> 由于prior 可能会不大好理解，这里再详细解释一下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  level ,test_id, pid, test_val <span class="keyword">from</span> test_tree  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> test_id<span class="operator">=</span><span class="number">10</span> <span class="keyword">CONNECT</span> <span class="keyword">BY</span>  prior test_id<span class="operator">=</span> pid <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">10</span>	<span class="number">0</span>	  Database</span><br><span class="line"><span class="number">2</span>	<span class="number">11</span>	<span class="number">10</span>	DB2</span><br><span class="line"><span class="number">2</span>	<span class="number">12</span>	<span class="number">10</span>	MySQL</span><br><span class="line"><span class="number">2</span>	<span class="number">13</span>	<span class="number">10</span>	Oracle</span><br><span class="line"><span class="number">2</span>	<span class="number">14</span>	<span class="number">10</span>	<span class="keyword">SQL</span> Server</span><br><span class="line"><span class="number">3</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">3</span>	<span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">4</span>	<span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span></span><br><span class="line"><span class="number">4</span>	<span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span></span><br><span class="line"><span class="number">4</span>	<span class="number">18</span>	<span class="number">15</span>	Package</span><br><span class="line"><span class="number">4</span>	<span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span></span><br><span class="line"></span><br><span class="line">                                此时 形成的 树形结构为</span><br><span class="line">         level <span class="number">1</span>                    <span class="number">10</span></span><br><span class="line">                                    ｜</span><br><span class="line">                         ————————<span class="comment">----------————————</span></span><br><span class="line">                        ｜      ｜       ｜        ｜</span><br><span class="line">         level <span class="number">2</span>        <span class="number">11</span>      <span class="number">12</span>      <span class="number">13</span>        <span class="number">14</span>     <span class="comment">-----&gt; prior 指定 父行</span></span><br><span class="line">                        ｜      ｜       ｜        ｜</span><br><span class="line">         level <span class="number">3</span>                        <span class="number">15</span>        <span class="number">20</span>     <span class="comment">-----&gt; prior 指定</span></span><br><span class="line">                                          <span class="operator">|</span></span><br><span class="line">                                  <span class="comment">---------------</span></span><br><span class="line">                                  <span class="operator">|</span>    <span class="operator">|</span>    <span class="operator">|</span>    <span class="operator">|</span></span><br><span class="line">                                  <span class="number">16</span>   <span class="number">17</span>  <span class="number">18</span>    <span class="number">19</span></span><br><span class="line">         level <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- prior 在另一侧，修改一下 start with 的条件。</span></span><br><span class="line"><span class="keyword">SELECT</span>  level ,test_id, pid, test_val <span class="keyword">from</span> test_tree  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> test_id <span class="operator">=</span> <span class="number">15</span> <span class="keyword">CONNECT</span> <span class="keyword">BY</span> test_id <span class="operator">=</span> prior pid <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span></span><br><span class="line"><span class="number">2</span>	<span class="number">13</span>	<span class="number">10</span>	Oracle</span><br><span class="line"><span class="number">3</span>	<span class="number">10</span>	<span class="number">0</span>		Database</span><br><span class="line"></span><br><span class="line">                         此时 形成的 树形结构为</span><br><span class="line">         level <span class="number">1</span>             <span class="number">13</span>      <span class="comment">----&gt; prior 指定的父行pid = 13</span></span><br><span class="line">                             <span class="operator">|</span></span><br><span class="line">         level <span class="number">2</span>            <span class="number">10</span></span><br><span class="line">                             <span class="operator">|</span></span><br><span class="line">       	 level <span class="number">3</span>             <span class="number">0</span></span><br><span class="line"></span><br><span class="line">     </span><br></pre></td></tr></table></figure>



<p>完整功能</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 完整的功能有 10 个。</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">test_id, pid, test_val,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 操作符</span></span><br><span class="line">connect_by_root test_id ,</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 函数</span></span><br><span class="line">SYS_CONNECT_BY_PATH(pid, <span class="string">&#x27;/&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 伪列(三个)</span></span><br><span class="line">CONNECT_BY_ISCYCLE,</span><br><span class="line"><span class="comment">-- 4.</span></span><br><span class="line">CONNECT_BY_ISLEAF,</span><br><span class="line"><span class="comment">-- 5.</span></span><br><span class="line">level</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test_tree  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 根行</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> test_id<span class="operator">=</span><span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 父行和子行的关系</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> nocycle <span class="comment">/* 8. ( cycle ) */</span> prior <span class="comment">/* 9. 操作符 */</span> test_id<span class="operator">=</span> pid </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10. 排序</span></span><br><span class="line"><span class="keyword">ORDER</span> SIBLINGS <span class="keyword">BY</span> test_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>	<span class="number">0</span>		Database		<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span>					<span class="number">0</span>	<span class="number">0</span>	<span class="number">1</span></span><br><span class="line"><span class="number">11</span>	<span class="number">10</span>	DB2					<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span>				<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span></span><br><span class="line"><span class="number">12</span>	<span class="number">10</span>	MySQL				<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span>				<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span></span><br><span class="line"><span class="number">13</span>	<span class="number">10</span>	Oracle			<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span>				<span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span></span><br><span class="line"><span class="number">15</span>	<span class="number">13</span>	PL<span class="operator">/</span><span class="keyword">SQL</span>			<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">13</span>		<span class="number">0</span>	<span class="number">0</span>	<span class="number">3</span></span><br><span class="line"><span class="number">16</span>	<span class="number">15</span>	<span class="keyword">Function</span>		<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">13</span><span class="operator">/</span><span class="number">15</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">4</span></span><br><span class="line"><span class="number">17</span>	<span class="number">15</span>	<span class="keyword">Procedure</span>		<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">13</span><span class="operator">/</span><span class="number">15</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">4</span></span><br><span class="line"><span class="number">18</span>	<span class="number">15</span>	Package			<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">13</span><span class="operator">/</span><span class="number">15</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">4</span></span><br><span class="line"><span class="number">19</span>	<span class="number">15</span>	<span class="keyword">Cursor</span>			<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">13</span><span class="operator">/</span><span class="number">15</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">4</span></span><br><span class="line"><span class="number">14</span>	<span class="number">10</span>	<span class="keyword">SQL</span> Server	<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span>				<span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span></span><br><span class="line"><span class="number">20</span>	<span class="number">14</span>	T<span class="operator">-</span><span class="keyword">SQL</span>				<span class="number">10</span>	<span class="operator">/</span><span class="number">0</span><span class="operator">/</span><span class="number">10</span><span class="operator">/</span><span class="number">14</span>		<span class="number">0</span>	<span class="number">1</span>	<span class="number">3</span></span><br></pre></td></tr></table></figure>





<h2 id="6-SQL-标准-CTE"><a href="#6-SQL-标准-CTE" class="headerlink" title="6. SQL 标准 CTE"></a>6. SQL 标准 CTE</h2><h3 id="6-1-CTE-描述"><a href="#6-1-CTE-描述" class="headerlink" title="6.1 CTE 描述"></a>6.1 CTE 描述</h3><p> **common table expression **或 CTE 是从简单的 SELECT 语句创建的临时命名结果集，可用于后续的 SELECT 语句。 每个 SQL CTE 就像一个命名查询，其结果存储在一个虚拟表 (CTE) 中，以便稍后在主查询中引用。</p>
<h3 id="6-2-CTE实现-connect-by"><a href="#6-2-CTE实现-connect-by" class="headerlink" title="6.2 CTE实现 connect by"></a>6.2 CTE实现 connect by</h3><p>我们之间将如何使用 CTE 来实现 oracle 的层级查询功能，直接看例子。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- connect by</span></span><br><span class="line"><span class="keyword">SELECT</span>  level ,test_id, pid, test_val <span class="keyword">from</span> test_tree  </span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> test_id<span class="operator">=</span><span class="number">10</span> <span class="keyword">CONNECT</span> <span class="keyword">BY</span>  prior test_id<span class="operator">=</span> pid <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> LEVEL, empno, ename, mgr, sal</span><br><span class="line"><span class="keyword">FROM</span> emp_</span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> PRIOR empno <span class="operator">=</span> mgr</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> ename <span class="operator">=</span> <span class="string">&#x27;BLAKE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ctes 实现上述 层次查询</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> cte_tab(level, test_id, pid, test_val) &#123;</span><br><span class="line">	<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">AS</span> level,test_id, pid, test_val <span class="keyword">from</span> test_tree <span class="keyword">where</span> test_id<span class="operator">=</span><span class="number">10</span> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">	<span class="keyword">select</span>  cte_tab.level<span class="operator">+</span><span class="number">1</span> ,test_treetest_.id, test_tree.pid, test_tree.test_val <span class="keyword">from</span> test_tree, cte_tab </span><br><span class="line">	<span class="keyword">where</span> cte_tab.test_id<span class="operator">=</span> test_val.pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cte_tab;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="7-connect-by-算法"><a href="#7-connect-by-算法" class="headerlink" title="7. connect by 算法"></a>7. connect by 算法</h2><p>是一个查找算法。看完补充</p>
<h3 id="7-1-基本算法描述"><a href="#7-1-基本算法描述" class="headerlink" title="7.1 基本算法描述"></a>7.1 基本算法描述</h3><p>TODO </p>
<h3 id="7-2-算法伪代码"><a href="#7-2-算法伪代码" class="headerlink" title="7.2 算法伪代码"></a>7.2 算法伪代码</h3><p>后续补充。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>从零写数据库系列-背景知识</title>
    <url>/2023/02/01/2-%E6%95%B0%E6%8D%AE%E5%BA%93/3-%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%E9%9B%B6%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B01-%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1970 年，IBM的研究员Edgar Frank Codd (TED) 发表了《A Relational Model of Data for Large Shared Data Banks》，这篇论文首次提出了关系模型。</p>
<p>1972年，TED 又提出了关系大事和关系演算的概念。</p>
<p>1974年，IBM的Ray Boyce和Don Chamberlin提出了SQL（Structured Query Language）语言。</p>
<p>有了关系模型和关系代数的理论基础，又有了SQL 这种语言来表达。那么我们可以开始设计数据库系统了。</p>
<p>在关系模型提出后，出现过两个著名的产品，System R 和 Ingres。Ingres使用的是一种叫做 QUEL 的语言，System R使用的就是早期的 SQL。由于 SQL 成为了 ANSI 的标准，所以QUEL 成为了历史。</p>
<span id="more"></span>

<p>有了这些历史背景，现在可以谈谈SQL的执行流程了。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>词法(lexing)，语法(syntax)。</p>
<h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><p>语意(Semantic)。绑定，类型检查。</p>
<h2 id="Planner"><a href="#Planner" class="headerlink" title="Planner"></a>Planner</h2><p>System R优化器第一次提出了自底向上的动态规划搜索策略，影响了后续的很多系统。另一个创新点在于提出来基于cost-based的优化方法，如何根据sargable条件计算selective，增加了interesting order属性来对访问方法（Access Path）进行影响。</p>
<p>Volcano&#x2F;Cascades</p>
<p>Cascades 的实现，orca，cockroachdb。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *scope)</span></span> endAggFunc(cols opt.ColSet) (g *groupby) &#123;</span><br><span class="line">	<span class="keyword">if</span> !s.inAgg &#123;</span><br><span class="line">		<span class="built_in">panic</span>(errors.AssertionFailedf(<span class="string">&quot;mismatched calls to start/end aggFunc&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	s.inAgg = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> curr := s; curr != <span class="literal">nil</span>; curr = curr.parent &#123;</span><br><span class="line">		<span class="keyword">if</span> cols.Len() == <span class="number">0</span> || cols.Intersects(curr.colSet()) &#123;</span><br><span class="line">			curr.verifyAggregateContext()</span><br><span class="line">			<span class="keyword">if</span> curr.groupby == <span class="literal">nil</span> &#123;</span><br><span class="line">				curr.initGrouping()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> curr.groupby</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(errors.AssertionFailedf(<span class="string">&quot;aggregate function is not allowed in this context&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>从零写数据库系列-scanner</title>
    <url>/2023/02/01/2-%E6%95%B0%E6%8D%AE%E5%BA%93/3-%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%E9%9B%B6%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B02-scanner/</url>
    <content><![CDATA[<span id="more"></span>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>CockRoackDB 概述</title>
    <url>/2023/01/31/2-%E6%95%B0%E6%8D%AE%E5%BA%93/1-cockroachdb/cockorachdb%20%E4%B9%8B%2001-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>CockroachDB 设计的两个目标：可拓展和一致性。开发者经常会有疑问我们是如何做到的。这篇文章详细解释CockroachDB的内部工作原理。对于使用者来说，不需要了解底层架构，所以此文是为了那些想要了解底层的用户。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>CockroachDB 设计目标：</p>
<ul>
<li>使人们的生活更轻松，这意味着对于用户来说高度自动化，对于开发者来说更简单。</li>
<li>提供行业领先的一致性，即使在大规模部署当中也是，这意味着使用分布式事务，以及消除最终一致性问题和 过期读的问题。</li>
<li>创建一个始终在线的数据库，该数据库所有节点接受读和写，而不产生冲突。</li>
<li>允许在任何平台中部署，不需要绑定平台和供应商。</li>
<li>支持处理关系数据的工具，比如SQL。</li>
</ul>
<p>通过这些特性的融合，我们希望 CockroachDB 帮助您构建全球性、可扩展、弹性的部署和应用程序。</p>
<p>在阅读我们的架构文档之前了解一些术语会很有帮助。</p>
<span id="more"></span>

<h2 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h2><table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td>Consistency</td>
<td>事务必须仅以允许的方式更改受影响数据的要求。 CockroachDB 在 ACID 语义和 CAP 定理的意义上都使用了“一致性”，尽管没有任何一个定义那么正式。</td>
</tr>
<tr>
<td>isolation</td>
<td>一个事务可能受同时运行的其他事务影响的程度。 CockroachDB 提供了 SERIALIZABLE 隔离级别，这是可能的最高级别，并保证每个提交的事务具有相同的结果，就好像每个事务一次运行一个一样。</td>
</tr>
<tr>
<td>Consensus</td>
<td>就事务是提交还是中止达成一致的过程。 CockroachDB 使用 Raft 共识协议。 在 CockroachDB 中，当一个范围接收到写入时，包含该范围副本的节点的法定人数会确认写入。 这意味着您的数据得到安全存储，并且大多数节点都同意数据库的当前状态，即使某些节点处于脱机状态。<br/><br/>当写入未达成共识时，前进进程停止以保持集群内的一致性。</td>
</tr>
<tr>
<td>Replication</td>
<td>创建和分发数据副本以及确保这些副本保持一致的过程。 CockroachDB 要求所有写入在被视为已提交之前传播到数据副本的法定人数。 这确保了数据的一致性。</td>
</tr>
<tr>
<td>transation</td>
<td>在数据库上执行的一组满足 ACID 语义要求的操作。 这是确保开发人员可以信任其数据库中的数据的一致系统的关键特性。 有关 CockroachDB 中事务如何工作的更多信息，请参阅事务层。</td>
</tr>
<tr>
<td>Multi-active availability</td>
<td>一种基于共识的高可用性概念，允许集群中的每个节点处理存储数据子集的读取和写入（基于每个范围）。 这与主动-被动复制（主动节点接收 100% 的请求流量）和主动-主动复制（所有节点都接受请求但通常不能保证读取是最新的和快速的）形成对比。</td>
</tr>
</tbody></table>
<h2 id="CockroachDB-架构术语"><a href="#CockroachDB-架构术语" class="headerlink" title="CockroachDB 架构术语"></a>CockroachDB 架构术语</h2><table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td>cluster</td>
<td>一组相互连接的存储节点，它们协作组织事务、容错和数据重新平衡。</td>
</tr>
<tr>
<td>node</td>
<td>CockroachDB 的单个实例。 一个或多个节点形成一个集群。</td>
</tr>
<tr>
<td>range</td>
<td>CockroachDB 将所有用户数据（表、索引等）和几乎所有系统数据存储在键值对的排序映射中。 这个键空间被分成称为范围的连续块，这样每个键都可以在一个范围内找到。<br/><br/>从 SQL 的角度来看，表及其二级索引最初映射到单个范围，其中范围中的每个键值对代表表中的单个行（也称为主索引，因为表是按主键排序的） 或二级索引中的单行。 一旦范围的大小达到 512 MiB（默认值），它就会被分成两个范围。 随着表及其索引的不断增长，这些新范围的过程将继续进行。</td>
</tr>
<tr>
<td>Replica</td>
<td>存储在节点上的范围的副本。 默认情况下，每个范围在不同节点上有三个副本。</td>
</tr>
<tr>
<td>Leasholder</td>
<td>持有“范围租约”的副本。 此副本接收并协调该范围的所有读取和写入请求。<br/><br/>对于大多数类型的表和查询，租用者是唯一可以提供一致读取（返回“最新”数据的读取）的副本。</td>
</tr>
<tr>
<td>raft protocol</td>
<td>CockreactDB中采用的共识协议可确保您的数据安全存储在多个节点上，并且这些节点即使其中一些暂时断开连接，也可以同意当前状态。</td>
</tr>
<tr>
<td>Raft leader</td>
<td>对于每个范围，是写作请求的“领导者”的副本。 领导者使用 raft 协议来确保大多数复本（领导者和足够的追随者）根据其 raft 日志达成一致，然后再进行写作。 raft 领导人几乎总是与 leaseholder 是相同的复本。</td>
</tr>
<tr>
<td>Raft log</td>
<td>按时间订购的日志写入其复制品已达成协议的范围。 该日志与每个副本一起存在，并且是一致复制的真实范围的来源。</td>
</tr>
</tbody></table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CockroachDB 在机器上启动使用下面两条命令。</p>
<ul>
<li>cockroach  start 启动集群中所有节点使用 –jion 标记 ，因此该过程知道它可以与之通信的所有其他机器。</li>
<li>cockroach init执行初始化集群。</li>
</ul>
<p>一旦初始化了CockacredDB群集，开发人员就会通过兼容 postgresql 的SQL API与CockreactDB相互作用。 得益于群集中所有节点的对称行为，您可以将SQL请求发送到任何节点； 这使蟑螂易于与负载平衡器集成。</p>
<p>接收SQL远程过程调用（RPC）后，节点将它们转换为 kv 操作 在分布式事务的存储中。</p>
<p>当这些RPC开始用数据填充群集时，CockroachdB开始算法将您的数据分配在群集的节点之间，将数据分解为我们称为 ragne 的512个MIB块。 默认情况下，每个range 至少复制至至少3个节点，以确保生存能力。 这样可以确保如果有任何节点下降，您仍然拥有可用于以下数据的数据的副本：</p>
<ul>
<li>继续提供读写。</li>
<li>持续负责数据到其他节点。</li>
</ul>
<p>如果一个节点接收到读或写请求无法直接处理，它会找到可以处理该请求的节点，并与该节点通信。这意味着您不需要知道在群集中存储了数据的特定部分；CockroachDB 为您跟踪它，并启用每个节点的对称读&#x2F;写行为。</p>
<p>对数据范围内对数据进行的任何更改都取决于共识算法，以确保大多数范围的复制品同意进行更改。 这就是蟑螂实现行业领先的隔离的方式，可以使其能够为您的应用提供一致的读取和写入，而不管您与哪种节点进行了交流。</p>
<p>最终，使用有效的存储引擎将数据写入并从磁盘上读取，该引擎能够跟踪数据的时间戳。 这是一个好处，可以让我们支持AS OF SYSTEM TIME 的SQL标准，从而让您在一段时间内找到历史数据。</p>
<h2 id="五层"><a href="#五层" class="headerlink" title="五层"></a>五层</h2><table>
<thead>
<tr>
<th>Layer</th>
<th>Order</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>SQL</td>
<td>1</td>
<td>转换 sql 到 kv 操作</td>
</tr>
<tr>
<td>Transitional</td>
<td>2</td>
<td>允许原子修改 多个kv 操作</td>
</tr>
<tr>
<td>Distribution</td>
<td>3</td>
<td>复制 kv range</td>
</tr>
<tr>
<td>Replication</td>
<td>4</td>
<td>一致和同步复制KV范围在许多节点上范围。 该层还可以使用共识算法进行一致的读取</td>
</tr>
<tr>
<td>Storage</td>
<td>5</td>
<td>读写 kv 在磁盘</td>
</tr>
</tbody></table>
<h1 id="SQL-层"><a href="#SQL-层" class="headerlink" title="SQL 层"></a>SQL 层</h1><p>sql 层给 开发者提供 SQL API 并且将 sql 语句转换为 读写请求到 key-velue store。并且通过事务层。</p>
<p>包含以下子层：</p>
<ul>
<li>sql api，用户的接口</li>
<li>Parser， 将sql 语句转换为 AST树</li>
<li>Cost-based optimizer，将 AST树转换为被优化的逻辑计划</li>
<li>Physical planner 将逻辑计划转换为物理计划，给集群中一个或者多个节点执行</li>
<li>SQL execution engine，执行物理计划通过创建 读写请求给底层的 key-value store</li>
</ul>
<h2 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h2><p>一旦CockroachDB被部署成功，开发者们需要一个连接串连接到集群，他们可以开始工作使用 SQL。</p>
<p>因为CockroachDB集群中每个节点上对等的，开发者可以从任何一个节点发送请求。接受请求的节点称为”gateway node”，执行请求并且响应客户端。</p>
<p>对集群的请求以 SQL 语句的形式到达，但数据最终以键值 (KV) 对的形式写入和读取存储层。 为了处理这个问题，SQL 层将 SQL 语句转换为 KV 操作计划，然后将其传递给事务层。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="关系结构"><a href="#关系结构" class="headerlink" title="关系结构"></a>关系结构</h3><p>开发人员将存储在 CockroachDB 中的数据视为由行和列组成的关系结构。 行和列的集合被进一步组织成表格。 然后将表的集合组织到数据库中。 CockroachDB 集群可以包含许多数据库。</p>
<p>CockroachDB 提供了典型的关系特征，如约束（例如外键）。 这些特性意味着应用程序开发人员可以相信数据库将确保应用程序数据的结构一致； 数据验证不需要单独构建到应用程序逻辑中。</p>
<h3 id="SQL-API"><a href="#SQL-API" class="headerlink" title="SQL API"></a>SQL API</h3><p>CockroachDB 实现了大部分 ANSI SQL 标准以显示其关系结构。</p>
<p>重要的是，通过 SQL API，开发人员可以像通过任何 SQL 数据库（使用 BEGIN、COMMIT 等）一样访问 ACID 语义事务。</p>
<h3 id="PostgreSQL-wire-protocol"><a href="#PostgreSQL-wire-protocol" class="headerlink" title="PostgreSQL wire protocol"></a>PostgreSQL wire protocol</h3><p>SQL 查询通过 PostgreSQL 协议访问集群。 </p>
<h3 id="SQL-parser-planner-executor"><a href="#SQL-parser-planner-executor" class="headerlink" title="SQL parser, planner, executor"></a>SQL parser, planner, executor</h3><p>当 CockroachDB 集群中的节点接收到来自客户端的 SQL 请求时，它会解析语句并创建优化的逻辑查询计划，该计划会进一步转换为物理查询计划。 最后，执行物理计划。</p>
<h4 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h4><p>SQL 查询根据我们的 yacc 文件（描述我们支持的语法）进行解析，每个查询的 SQL 版本都被转换为抽象语法树 (AST)。</p>
<h4 id="Logical-planning"><a href="#Logical-planning" class="headerlink" title="Logical planning"></a>Logical planning</h4><p>在逻辑计划阶段，AST 树被转换为一个查询计划通过以下步骤。</p>
<ol>
<li>AST 被转换为高级逻辑查询计划。 在此转换过程中，CockroachDB 还执行语义分析，其中包括以下操作：</li>
</ol>
<ul>
<li>检查查询是否是 SQL 语言中的有效语句。</li>
<li>将名称（例如表或变量的名称）解析为其值。</li>
<li>消除不需要的中间计算，例如，将 0.6 + 0.4 替换为 1.0。 这也称为常量折叠。</li>
<li>最终确定用于中间结果的数据类型，例如，当查询包含一个或多个子查询时。</li>
</ul>
<ol start="2">
<li>使用一系列始终有效的转换简化了逻辑计划。 例如，a BETWEEN b AND c 可以转换为 a &gt;&#x3D; b AND a &lt;&#x3D; c。</li>
<li>使用搜索算法优化逻辑计划，该算法评估执行查询的许多可能方式并选择成本最低的执行计划。</li>
</ol>
<p>上述最后一步的结果是优化的逻辑计划。 要查看基于成本的优化器生成的逻辑计划，请使用 EXPLAIN (OPT) 语句。</p>
<h4 id="Physical-planning"><a href="#Physical-planning" class="headerlink" title="Physical planning"></a>Physical planning</h4><p>物理计划阶段根据 range 的位置信息决定那个节点参与查询的执行。这就是CockroachDB 决定分布式执行在靠近存储位置的地方。</p>
<p>更具体地说，物理计划阶段将 逻辑计划期间生成 的 逻辑计划 转换为物理 SQL 运算符的有向无环图 (DAG)。 可以通过运行 EXPLAIN(DISTSQL) 语句查看这些运算符。</p>
<p>关于是否在多个节点上分发查询的决定是由一种启发式方法做出的，该方法估计需要通过网络发送的数据量。 只需要少量行的查询在网关节点上执行。 其他查询分布在多个节点上。</p>
<p>例如，当一个查询被分发时，物理计划阶段将扫描操作从逻辑计划拆分为多个物理 TableReader 操作符，每个节点一个包含扫描读取的范围。 然后将剩余的逻辑操作（可能执行过滤器、连接和聚合）安排在与 TableReader 相同的节点上。 这导致执行的计算尽可能接近物理数据。</p>
<h4 id="Query-execution"><a href="#Query-execution" class="headerlink" title="Query execution"></a>Query execution</h4><p>物理计划的组成部分被发送到一个或多个节点执行。 在每个节点上，CockroachDB 生成一个逻辑处理器来计算查询的一部分。 节点内部或跨节点的逻辑处理器通过逻辑数据流相互通信。 查询的组合结果被发送回接收查询的第一个节点，以进一步发送到 SQL 客户端。</p>
<p>每个处理器对查询操作的标量值使用编码形式。 这是一种二进制形式，不同于 SQL 中使用的形式。 因此，SQL 查询中列出的值必须进行编码，并且在逻辑处理器之间通信以及从磁盘读取的数据必须在将其发送回 SQL 客户端之前进行解码。</p>
<h4 id="Vectorized-query-execution"><a href="#Vectorized-query-execution" class="headerlink" title="Vectorized query execution"></a>Vectorized query execution</h4><p>如果启用了向量化执行，则将物理计划发送到节点以由向量化执行引擎处理。</p>
<p>向量化引擎收到物理计划后，从磁盘中批量读取表数据，并将数据从行格式转换为列格式。 这些批次的列数据存储在内存中，因此引擎可以在执行过程中快速访问它们。</p>
<p>矢量化引擎使用专门的预编译函数，可以快速迭代特定类型的列数据数组。 当引擎处理每列数据时，函数的列输出存储在内存中。</p>
<p>在处理完输入缓冲区中的所有列数据后，引擎将列输出转换回行格式，然后将处理后的行返回给 SQL 接口。 当一批表数据处理完毕后，引擎会读取下一批表数据进行处理，直到查询执行完毕。</p>
<h3 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h3><p>尽管 SQL 查询是用可解析的字符串编写的，但 CockroachDB 的较低层主要以字节为单位处理。 这意味着在 SQL 层，在查询执行中，CockroachDB 必须将行数据从它们的 SQL 表示形式转换为字节，并将从较低层返回的字节转换为可以传递回客户端的 SQL 数据。</p>
<p>同样重要的是——对于索引列——这种字节编码保持与它所代表的数据类型相同的排序顺序。 这是因为 CockroachDB 最终将数据存储在排序的键值映射中的方式； 以与其所代表的数据相同的顺序存储字节使我们能够有效地扫描 KV 数据。</p>
<p>然而，对于非索引列（例如，非 PRIMARY KEY 列），CockroachDB 改为使用占用较少空间但不保留排序的编码（称为“值编码”）。</p>
<h3 id="DistSQL"><a href="#DistSQL" class="headerlink" title="DistSQL"></a>DistSQL</h3><p>因为 CockroachDB 是一个分布式数据库，所以我们为一些查询开发了一个分布式 SQL（DistSQL）优化工具，它可以显着加快涉及多个范围的查询。 尽管 DistSQL 的体系结构值得拥有它自己的文档，但这个粗略的解释可以提供一些关于它是如何工作的洞察力。</p>
<p>在非分布式查询中，协调节点接收与其查询匹配的所有行，然后对整个数据集执行任何计算。</p>
<p>但是，对于与 DistSQL 兼容的查询，每个节点都会对其包含的行进行计算，然后将结果（而不是整个行）发送到协调节点。 协调节点然后聚合来自每个节点的结果，最后向客户端返回单个响应。</p>
<p>这大大减少了带到协调节点的数据量，并利用了经过充分验证的并行计算概念，最终减少了完成复杂查询所需的时间。 此外，这会在已经存储数据的节点上处理数据，这让 CockroachDB 可以处理大于单个节点存储的行集。</p>
<p>为了以分布式方式运行 SQL 语句，我们引入了几个概念：</p>
<ul>
<li>逻辑计划：类似于上面描述的 AST&#x2F;planNode 树，它表示通过计算阶段的抽象（非分布式）数据流。</li>
<li>物理计划：物理计划在概念上是逻辑计划节点到运行 cockroach 的物理机器的映射。 逻辑计划节点根据集群拓扑进行复制和专门化。 与上面的 planNodes 一样，物理计划的这些组件是在集群上调度和运行的。</li>
</ul>
<h2 id="Schema-changes"><a href="#Schema-changes" class="headerlink" title="Schema changes"></a>Schema changes</h2><p>CockroachDB 使用允许表在模式更改期间保持在线（即能够提供读取和写入服务）的协议来执行模式更改，例如添加列或二级索引。 该协议允许集群中的不同节点在不同时间异步转换到新的表模式。</p>
<p>模式更改协议将每个模式更改分解为一系列增量更改，以达到预期的效果。</p>
<p>例如，添加二级索引需要在开始版本和结束版本之间有两个中间架构版本，以确保索引在整个集群中的写入时更新，然后才可用于读取。 为了确保数据库在整个模式更改过程中保持一致状态，我们强制执行不变量，即在集群中始终使用最多两个连续版本的该模式。</p>
<h1 id="事务层"><a href="#事务层" class="headerlink" title="事务层"></a>事务层</h1><p>事务层实现对事务 ACID 的支持通过协调当前的操作。</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>CockroachDB 认为一致性是数据库最重要的特征。没有他，开发者不能构建可靠的工具，企业将遭受潜在的微妙的难以发现的异常。</p>
<p>为了提供一致性，CockroachDB实现了完整的 ACID事务语法在事务层。然而，最重要的是，所有的语句都是作为事务来处理的，包括单条语句，这有时被称为“autocommit mode”，因为它的行为就像每条语句后面都有一个 COMMIT。</p>
<p>因为 CockroachDB 支持跨整个集群的事务（包括跨范围和跨表事务），所以它使用称为 Parallel Commits 的分布式原子提交协议来实现正确性。</p>
<h3 id="Writes-and-reads-phase-1"><a href="#Writes-and-reads-phase-1" class="headerlink" title="Writes and reads (phase 1)"></a>Writes and reads (phase 1)</h3><h4 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h4><p>当事务层执行写操作的时候，他不直接将值写到磁盘中，他会创建以下几种事情帮助协调分布式事务：</p>
<ul>
<li><p><strong>Locks</strong> 所有事务的写，表示临时的、未提交的状态。 CockroachDB 有几种不同类型的锁：</p>
<ul>
<li><p><strong>Unreplicated Locks</strong> are stored in an in-memory, per-node lock table by the <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer.html#concurrency-control">concurrency control</a> machinery. These locks are not replicated via <a href="https://www.cockroachlabs.com/docs/v21.2/architecture/replication-layer#raft">Raft</a>.</p>
</li>
<li><p><strong>Replicated Locks</strong> (also known as <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer.html#write-intents">write intents</a>) are replicated via <a href="https://www.cockroachlabs.com/docs/v21.2/architecture/replication-layer#raft">Raft</a>, and act as a combination of a provisional value and an exclusive lock. They are essentially the same as standard <a href="https://www.cockroachlabs.com/docs/v21.2/architecture/storage-layer#mvcc">multi-version concurrency control (MVCC)</a> values but also contain a pointer to the <a href="https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer.html#transaction-records">transaction record</a> stored on the cluster.</p>
</li>
</ul>
</li>
<li><p>A <strong>transaction record</strong> stored in the range where the first write occurs, which includes the transaction’s current state (which is either <code>PENDING</code>, <code>STAGING</code>, <code>COMMITTED</code>, or <code>ABORTED</code>).</p>
</li>
</ul>
<h4 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h4><p>如果事务没有被终止，事务层执行读操作。如果一个读操作遇到了标准的 MVCC 值，一切都很好。但是如果遇到了 写意向，操作必须解决事务冲突。</p>
<p>CockroachDB 提供两种类型的读：</p>
<ul>
<li>强一致性读：这是默认的也是最常用的读。这些读通过 leaseholder 并且可以看到读事务开始之前的所有写。他们总是返回正确最新的数据。</li>
<li>stale reads：这是有用的在你想要获取更快的读，而不是更新的数据的时候。他们可以用只读事务使用 <code>AS OF SYSTEM TIME</code> 语句。他们不需要通过 leaseholder ，因为他们可以确保一致性读通过读取不高于 closed timestamp 时间戳的本地副本。详细看 foller Rdads。<font color='red'> 为什么在非 leaseholder 上读，说明 leaseholder 可以看到最新的写，非leaseholder看不到 ？</font></li>
</ul>
<h3 id="Commits-phase-2"><a href="#Commits-phase-2" class="headerlink" title="Commits (phase 2)"></a>Commits (phase 2)</h3><p>CockroachDB 检查运行时的事务的记录，如果是 ABORTED。将重试事务。<font color='red'> 为什么会是 aborted ？</font></p>
<p>大多数情况下，他设置事务记录状态为 STAGING。检查 pending 状态事务的写意向事务已经成功（被集群复制）。</p>
<p><font color='red'>  如何检查是否被复制 ？</font></p>
<p>如果事务通过了检查，CockroacDB 返回客户端成功，进入 cleanup 阶段。到这时候，事务已经被提交。</p>
<p>关于更多的提交协议，看 并行提交。</p>
<h3 id="Cleanup-asynchronous-phase-3"><a href="#Cleanup-asynchronous-phase-3" class="headerlink" title="Cleanup (asynchronous phase 3)"></a>Cleanup (asynchronous phase 3)</h3><p>事务被提交后，他应当被标记，所有的写意向应该被解析。为了达到这个目的。 Coordinating 节点记录了所有写过的 keys。</p>
<p><font color='red'> 记录所有写过的 keys 干嘛用 ？清理的时候用</font></p>
<ul>
<li>将事务状态从 STAGING 改为 COMMITED。</li>
<li>解析事务的写意向到 MVCC。通过移除事务记录的指针。</li>
<li>删除写意向。</li>
</ul>
<p>这是一个简单的优化，如果操作遇到了写意向，他们总是检查事务状态，任何操作可以解析和移除写意向通过检查事务记录的状态。</p>
<h2 id="技术细节和组件"><a href="#技术细节和组件" class="headerlink" title="技术细节和组件"></a>技术细节和组件</h2><h3 id="时间和混合逻辑时钟"><a href="#时间和混合逻辑时钟" class="headerlink" title="时间和混合逻辑时钟"></a>时间和混合逻辑时钟</h3><p>在分布式系统中，排序和因果关系是一个复杂的问题。虽然可以完全依赖 Raft 共识来保持可序列化性，但读取数据效率低下。为了优化读性能，CockroachDB 实现了混合逻辑时钟，由一个物理组件（总是接近本地时间） 和一个逻辑组件（用于区分相同物理组件的事件）。这意味着 HTC 时间总是大于等于 wall time。</p>
<p><font color='red'> HLC 如何提高读性能 ？</font></p>
<p>在事务方面，网关节点总是给事务选择一个 HLC 时间戳。无论何时，当提及事务时间戳的时候，他一定是一个 HLC 时间，这个时间戳也会用来跟踪 MVCC 的值。提供事务一致性的保障。</p>
<p>当节点向其他节点发送请求时，它们包括由其本地 HLC 生成的时间戳（包括物理和逻辑组件）。 当节点接收到请求时，它们会将发送者随事件提供的时间戳通知其本地 HLC。 这对于保证节点上读取&#x2F;写入的所有数据的时间戳小于下一个 HLC 时间很有用。</p>
<p>然后，这让主要负责范围的节点（即，leaseholder）通过确保读取数据的事务处于大于它正在读取的 MVCC 值的 HLC 时间（即，读取总是发生在“之后 “写）。</p>
<h4 id="Max-clock-offset-enforcement"><a href="#Max-clock-offset-enforcement" class="headerlink" title="Max clock offset enforcement"></a>Max clock offset enforcement</h4><p>CockroachDB 需要中等级别的时钟同步以保持数据一致性。 出于这个原因，当一个节点检测到它的时钟与集群中至少一半的其他节点不同步到允许的最大偏移量（默认 500ms）的 80% 时，它会立即崩溃。</p>
<p>尽管无论时钟偏移如何都可以保持可串行化的一致性，但在配置的时钟偏移范围之外的偏移可能会导致因果相关事务之间的单键线性化违规。 因此，通过在每个节点上运行 NTP 或其他时钟同步软件来防止时钟漂移太远非常重要。</p>
<p><font color='red'>物理时钟不一致会导致什么问题  ? </font></p>
<h3 id="时间戳缓存-Timestamp-cache"><a href="#时间戳缓存-Timestamp-cache" class="headerlink" title="时间戳缓存 (Timestamp cache)"></a>时间戳缓存 (Timestamp cache)</h3><p>作为提供可串行化的一部分，每当一个操作读取一个值时，我们将操作的时间戳存储在时间戳缓存中，它显示正在读取的值的高水位标记。</p>
<p>时间戳缓存是一种数据结构，用于存储有关 leaseholders 执行的读取的信息。 这用于确保一旦某个事务 t1 读取一行，另一个出现并尝试写入该行的事务 t2 将在 t1 之后排序，从而确保事务的串行顺序，即可串行化。</p>
<p><font color='red'> 时间戳缓存在哪个节点存储 ？使用的时候怎么查找 ？</font></p>
<p>每当发生写入时，都会根据时间戳缓存检查其时间戳。 如果时间戳小于时间戳缓存的最新值，我们会尝试将其事务的时间戳推到稍后的时间。 推送时间戳可能会导致事务在事务的第二阶段重新启动（请参阅读取刷新）。</p>
<h3 id="Closed-timestamps"><a href="#Closed-timestamps" class="headerlink" title="Closed timestamps"></a>Closed timestamps</h3><p>每个 CockroachDB range 都跟踪一个称为其关闭时间戳的属性，这意味着永远不会在该时间戳或低于该时间戳时引入新的写入。 关闭的时间戳在 leaseholder 上连续提前，并且比当前时间滞后某个目标时间间隔。 随着关闭的时间戳提前，通知会发送给每个 follower。 如果某个 range 接受小于或等于其关闭时间戳的写，则写入将被迫更改其时间戳，这可能会导致事务重试错误（请参阅读取刷新）。</p>
<p><font color='red'> 所以到底能不能接受 小于 closed timestamps 的写 ？如果可以，什么情况下可以？ </font></p>
<p>换句话说，closed timestamp 是该 range 的 leaseholder 向其 follower 副本的承诺，即它不会接受低于该时间戳的写入。 一般来说，leaseholder 会在过去几秒钟内连续关闭时间戳。 ？？？</p>
<p><font color='red'> colsed timestamp 是在什么情况下生成？什么时候更新？  什么时候会删除 ？</font></p>
<p>Closed timestamps 子系统通过将 closed timestamps 捎带到 Raft 命令上来将信息从 leaseholders 有者传播到 followers，使复制流与timestamp closing 同步。 这意味着，一旦 followers 副本将所有 Raft 命令应用到由 leaseholder 指定的 Raft log 中的位置，它就可以开始提供时间戳等于或低于关闭时间戳的读取。</p>
<p>一旦 followers 副本应用了上述 Raft 命令，它就拥有了为时间戳小于或等于关闭时间戳的读取提供服务所需的所有数据。</p>
<p>请注意，即使承租人发生变化，关闭的时间戳也是有效的，因为它们会在租约转移中保留。 一旦发生租约转移，新的租约人将不会违反旧租约人作出的封闭时间戳承诺。</p>
<p>封闭的时间戳提供了用于为低延迟历史（陈旧）读取（也称为跟随者读取）提供支持的保证。 跟随者读取在多区域部署中特别有用。</p>
<p>有关关闭时间戳和 Follower Reads 实现的更多信息，请参阅我们的博客文章 An Epic Read on Follower Reads。</p>
<h3 id="client-Txn-and-TxnCoordSender"><a href="#client-Txn-and-TxnCoordSender" class="headerlink" title="client.Txn and TxnCoordSender"></a>client.Txn and TxnCoordSender</h3><p>正如我们在 SQL 层的架构概述中提到的，CockroachDB 将所有 SQL 语句转换为键值（KV）操作，这就是数据最终存储和访问的方式。</p>
<p>SQL 层生成的所有 KV 操作都使用 client.Txn，它是 CockroachDB KV 层的事务接口——但是，正如我们上面讨论的，所有语句都被视为事务，因此所有语句都使用该接口。</p>
<p>然而，client.Txn 实际上只是 TxnCoordSender 的一个包装器，它在我们的代码库中起着至关重要的作用：</p>
<ul>
<li>处理事务的状态。 事务启动后，TxnCoordSender 开始向该事务的事务记录异步发送心跳消息，这表明它应该保持活动状态。 如果 TxnCoordSender 的心跳停止，则事务记录将移至 ABORTED 状态。</li>
<li>在事务进行中跟踪每个 被写的 key 和 key range 。</li>
<li>清理累计的写意向当事务终止或者提交的时候，所有的请求都作为事务的一部分通过相同的 TxnCoordSender 统计所有的 写意向，从而优化 cleanup 阶段。</li>
</ul>
<p>在设置了这个簿记之后，请求被传递到分布层中的 DistSender。</p>
<h3 id="Transaction-records"><a href="#Transaction-records" class="headerlink" title="Transaction records"></a>Transaction records</h3><p>为了跟踪事务执行的状态，我们将一个称为事务记录的值写入我们的键值存储。 一个事务的所有写意图都指向这个记录，这让任何事务都可以检查它遇到的任何写意图的状态。 这种规范记录对于支持分布式环境中的并发性至关重要。</p>
<p>事务记录总是写入与事务中的第一个 key 相同的 range ，这由 TxnCoordSender 知道。 但是，在出现以下任一情况之前，不会创建交易记录本身：</p>
<ul>
<li>写操作提交</li>
<li>The <code>TxnCoordSender</code> heartbeats the transaction</li>
<li>An operation forces the transaction to abort 强制终止事务</li>
</ul>
<p>鉴于这种机制，事务记录使用以下状态：</p>
<ul>
<li><code>PENDING</code>: Indicates that the write intent’s transaction is still in progress. 表示写入意图的事务仍在进行中。</li>
<li><code>COMMITTED</code>: Once a transaction has completed, this status indicates that write intents can be treated as committed values.  一旦事务完成，此状态表明写入意图可以被视为已提交的值。</li>
<li>STAGING：用于启用并行提交功能。 根据此记录引用的写入意图的状态，事务可能处于提交状态，也可能不处于提交状态。<font color='red'>  什么情况下提交 ？什么情况下未提交？ </font></li>
<li><code>ABORTED</code>: Indicates that the transaction was aborted and its values should be discarded.</li>
<li>记录不存在：如果一个事务遇到一个事务记录不存在的写意图，它使用写意图的时间戳来确定如何进行。 如果写入意图的时间戳在事务活跃度阈值内，则写入意图的事务被视为处于待处理状态，否则视为事务已中止。</li>
</ul>
<p>已提交事务的事务记录将一直保留，直到其所有写入意图都转换为 MVCC 值。</p>
<h3 id="Write-intents"><a href="#Write-intents" class="headerlink" title="Write intents"></a>Write intents</h3><p>CockroachDB 中的值不会直接写入存储层； 相反，值以称为“写入意图”的临时状态写入。 这些本质上是 MVCC 记录，其中添加了一个附加值，用于标识该值所属的事务记录。 它们可以被认为是复制锁和复制临时值的组合。</p>
<p>每当操作遇到写入意图（而不是 MVCC 值）时，它都会查找事务记录的状态以了解它应该如何处理写入意图值。 如果事务记录丢失，则操作检查写入意图的时间戳并评估它是否被视为过期。</p>
<p>CockroachDB 使用每个节点的内存锁表来管理并发控制。 此表包含正在进行的事务获取的锁的集合，并在评估期间发现写入意图时包含有关写入意图的信息。 有关详细信息，请参阅下面有关并发控制的部分。</p>
<h4 id="Resolving-write-intents"><a href="#Resolving-write-intents" class="headerlink" title="Resolving write intents"></a>Resolving write intents</h4><p>当一个操作遇到了写意向，他尝试解析，解析的结果依赖写意向上的事务记录：</p>
<p>COMMITTED：该操作读取写意图并通过删除写意图指向事务记录的指针将其转换为 MVCC 值。</p>
<p>ABORTED：写入意图被忽略并删除。</p>
<p>PENDING：这表明存在必须解决的事务冲突。</p>
<p>STAGING：这表明操作需要检查 是否 staging 状态的事务还在运行中，通过检查 事务 coordinator 是否仍然在心跳事务记录，如果 coordinator 仍然在心跳事务记录，操作需要等待。 关于更多，参考并行提交。</p>
<h3 id="Concurrency-control"><a href="#Concurrency-control" class="headerlink" title="Concurrency control"></a>Concurrency control</h3><p>并发管理器对传入请求进行排序，并在发出那些打算执行冲突操作的请求的事务之间提供隔离。 此活动也称为并发控制。</p>
<p>并发管理器结合了 lath manager  和 lock table 的操作来完成这项工作：</p>
<ul>
<li>latch manager 对传入请求进行排序并在这些请求之间提供隔离。</li>
<li>锁表提供请求的锁定和排序（与锁管理器一致）。 它是一个每个节点的内存数据结构，其中包含由进行中事务获取的锁的集合。 为了确保与现有的写入意图系统（也称为复制的排他锁）的兼容性，它会在评估请求的过程中发现这些外部锁时根据需要提取有关这些外部锁的信息。</li>
</ul>
<p>并发管理器支持使用 SELECT FOR UPDATE 语句通过 SQL 进行悲观锁定。 此语句可用于增加吞吐量并减少竞争操作的尾部延迟。</p>
<p>有关 concurrency manager 如何与 latch manager  和 lock table 一起工作的更多详细信息，请参阅以下部分：</p>
<h4 id="Concurrency-manager"><a href="#Concurrency-manager" class="headerlink" title="Concurrency manager"></a>Concurrency manager</h4><p>并发管理器是一种结构，它对传入的请求进行排序，并在发出那些打算执行冲突操作的请求的事务之间提供隔离。 在排序过程中，发现冲突并通过被动排队和主动推送的组合来解决任何发现的问题。 一旦对请求进行排序，就可以自由评估，而不必担心由于管理器提供的隔离而与其他进行中的请求发生冲突。 这种隔离在请求的生命周期内得到保证，但在请求完成后终止。</p>
<h1 id="分布层"><a href="#分布层" class="headerlink" title="分布层"></a>分布层</h1><p>分布层为集群中的数据提供一个统一的视图。</p>
<h2 id="概览-2"><a href="#概览-2" class="headerlink" title="概览"></a>概览</h2><p>为了使用户可以从任何一个节点访问集群中的数据，CockroackDB 将数据以 kv 对的形式存储在一个整体有序的map中。这个 key 空间描述集群中的所有数据和数据的位置，数据被划分到了 ranges 中，所有的key 都可以被找到在 range中。</p>
<p>CockroachDB 实现排序的map以便：</p>
<ul>
<li><strong>Simple lookups</strong>：因为我们确定了哪些节点负责数据的某些部分，所以查询能够快速定位到哪里可以找到他们想要的数据。</li>
<li><strong>Efficient scans</strong>：通过定义数据的顺序，在扫描过程中很容易找到特定范围内的数据。</li>
</ul>
<h3 id="排序map-整体结构"><a href="#排序map-整体结构" class="headerlink" title="排序map 整体结构"></a>排序map 整体结构</h3><p>整体排序的 map 由两个基本元素组成：</p>
<ul>
<li>System data，包括集群中源数据的位置。（在学多其他集群范围和本地数据中）。</li>
<li>User data，存储集群中表数据。</li>
</ul>
<h4 id="Meta-ranges"><a href="#Meta-ranges" class="headerlink" title="Meta ranges"></a>Meta ranges</h4><p>集群中所有 range 的位置存储在键空间开头的两级索引中，称为meta ragnes，其中第一级 (meta1) 寻址第二级，第二级 (meta2) 寻址数据 集群。</p>
<p>这个两级索引加上用户数据可以可视化为一棵树，根在 meta1，第二级在 meta2，树的叶子由保存用户数据的范围组成。</p>
<p>重要的是，每个节点都有关于在哪里定位 meta1 范围的信息（称为其范围描述符，详情如下），并且该范围永远不会被分割。</p>
<p>默认情况下，这种元范围结构允许我们处理多达 4EiB 的用户数据：我们可以处理 2^(18 + 18) &#x3D; 2^36 个范围； 每个范围寻址 2^26 B，我们总共寻址 2^(36+26) B &#x3D; 2^62 B &#x3D; 4EiB。 但是，使用更大的范围大小，可以进一步扩展此容量。</p>
<p>元范围主要被视为正常范围，并且像集群的 KV 数据的其他元素一样被访问和复制。</p>
<p>每个节点缓存它之前访问过的 meta2 范围的值，从而优化将来对该数据的访问。 每当一个节点发现它的 meta2 缓存对于特定键无效时，缓存会通过对 meta2 范围执行定期读取来更新。</p>
<h4 id="Table-data"><a href="#Table-data" class="headerlink" title="Table data"></a>Table data</h4><p>在节点的元范围之后是集群存储的 KV 数据。</p>
<p>每个表及其二级索引最初都映射到一个范围，其中范围中的每个键值对代表表中的单个行（也称为主索引，因为该表是按主键排序的）或二级索引。一旦范围的大小达到 512 MiB，它就会分成两个范围。这个过程继续作为一个表，它的索引继续增长。一旦表被拆分为多个范围，表和二级索引很可能将存储在不同的范围中。但是，范围仍然可以包含表和二级索引的数据。</p>
<p>默认的 512 MiB 范围大小对我们来说是一个最佳点，它既小到可以在节点之间快速移动，又大到可以存储一组有意义的连续数据，这些数据的键更有可能被一起访问。然后，这些范围会在您的集群周围重新排列，以确保可生存性。</p>
<p>这些表范围被复制（在恰当命名的复制层中），并且每个副本的地址存储在 meta2 范围中。</p>
<h3 id="Using-the-monolithic-sorted-map"><a href="#Using-the-monolithic-sorted-map" class="headerlink" title="Using the monolithic sorted map"></a>Using the monolithic sorted map</h3><p>如元范围部分所述，集群中所有范围的位置存储在两级索引中：</p>
<ul>
<li>第一级 (meta1) 处理第二级。</li>
<li>第二级（meta2）处理用户数据。</li>
</ul>
<p>这也可以可视化为一棵树，根在 meta1，第二层在 meta2，树的叶子由保存用户数据的范围组成。</p>
<p>当一个节点收到一个请求时，它会以自下而上的方式查找包含请求中键的范围的位置，从这棵树的叶子开始。 此过程的工作方式如下：</p>
<ol>
<li>对于每个键，节点会在第二级范围元数据 (meta2) 中查找包含指定键的范围的位置。 该信息被缓存以提高性能； 如果在缓存中找到范围的位置，则立即返回。</li>
<li>如果在缓存中找不到范围的位置，则节点查找 meta2 的实际值所在的范围的位置。 此信息也被缓存； 如果在缓存中找到 meta2 范围的位置，则节点向 meta2 范围发送 RPC 以获取请求要操作的键的位置，并返回该信息。</li>
<li>最后，如果在缓存中找不到 meta2 范围的位置，则节点查找第一级范围元数据（meta1）的实际值所在的范围的位置。 这种查找总是成功的，因为 meta1 的位置使用 gossip 协议分布在集群中的所有节点之间。 然后节点使用来自 meta1 的信息来查找 meta2 的位置，并从 meta2 中查找包含请求中键的范围的位置。</li>
</ol>
<p>请注意，上述过程是递归的； 每次执行查找时，它要么 (1) 从缓存中获取位置，要么 (2) 对树中下一级“向上”的值执行另一次查找。 由于缓存了范围元数据，因此通常可以执行查找，而无需将 RPC 发送到另一个节点。</p>
<p>既然节点有了来自请求的键所在的范围的位置，它就会将请求中的 KV 操作发送到 BatchRequest 中的范围（使用 DistSender 机器）。</p>
<h2 id="技术细节和组件-1"><a href="#技术细节和组件-1" class="headerlink" title="技术细节和组件"></a>技术细节和组件</h2><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC 是用于相互通信的软件节点。 因为分发层是与其他节点通信的第一层，所以 CockroachDB 在这里实现了 gRPC。</p>
<p>gRPC 要求将输入和输出格式化为协议缓冲区（protobufs）。 为了利用 gRPC，CockroachDB 实现了 api.proto 中定义的基于协议缓冲区的 API。</p>
<h3 id="BatchRequest"><a href="#BatchRequest" class="headerlink" title="BatchRequest"></a>BatchRequest</h3><p>所有 KV 操作请求都捆绑到一个 protobuf 中，称为 BatchRequest。 此批次的目的地在 BatchRequest 标头中标识，以及指向请求的事务记录的指针。 （另一方面，当一个节点在回复一个 BatchRequest 时，它使用了一个 protobuf————BatchResponse。）</p>
<p>这个 BatchRequest 也用于使用 gRPC 在节点之间发送请求，它接受和发送协议缓冲区。</p>
<h3 id="DistSender"><a href="#DistSender" class="headerlink" title="DistSender"></a>DistSender</h3><h1 id="复制层"><a href="#复制层" class="headerlink" title="复制层"></a>复制层</h1><p>CockroachDB 的复制层拷贝数据在节点之间，并且通过一致性算法来确保拷贝数据的一致性。</p>
<h2 id="概览-3"><a href="#概览-3" class="headerlink" title="概览"></a>概览</h2><p>高可用需要数据库可以容忍节点下线而不打断服务，保证应用可用。这意味着需要复制数据在节点之间来确保数据仍然可以访问。</p>
<p>在节点离线的时候确保一致性是数据库的挑战。为了解决这个问题，CockroachDB 使用的一致性算法需要多数的副本同意修改才能提交修改。因为3 是一个最小的数字达到多数派，CockroachDB 最少需要 3 个节点。</p>
<h1 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h1><p>CockroachDB的存储层读写数据从磁盘上。</p>
<p><a href="https://www.cockroachlabs.com/blog/pebble-rocksdb-kv-store/">https://www.cockroachlabs.com/blog/pebble-rocksdb-kv-store/</a></p>
<h2 id="概览-4"><a href="#概览-4" class="headerlink" title="概览"></a>概览</h2><p>每个CockroachDB节点至少包含一个 store，在节点启动的时候指定，这是cockroach进程读写磁盘数据的位置。</p>
<p>数据以 key-value 的形式存储在存储引擎，被认为是 黑盒API。</p>
<p>CockroachDB使用 pebble 存储引擎，pebble 是受 RocksDB 启发，但是有不同：</p>
<ul>
<li>使用go语言并且实现 RocksDB 的一个子集。</li>
<li>包含有利于 CockroachDB 的优化。</li>
</ul>
<p>在内部，每个 store 包含两个存储引擎的实例：</p>
<ul>
<li>一个用来存储临时的分布式SQL数据。</li>
<li>一个存储节点所有的其他数据。</li>
</ul>
<p>此外，还有一个块缓存在一个节点的所有 store之间共享，这些 stores 又有 range 副本的集合。一个 range 的多个副本永远不会被放在一个 stroe 甚至是一个 节点。</p>
<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><h3 id="pebble"><a href="#pebble" class="headerlink" title="pebble"></a>pebble</h3><p>pebble 和 CockroachDB很好的集成有许多原因：</p>
<ul>
<li>他是一个 kv 存储，使得很容易引射成key -value。</li>
<li>提供原子写 batnches 和 snapshots，是事务的一个子集。</li>
<li>自研。</li>
<li>包含 rocksdb 中没有的优化，灵感来自 CockraochDb 如何使用 存储引擎。<a href="https://www.cockroachlabs.com/blog/bulk-data-import/">https://www.cockroachlabs.com/blog/bulk-data-import/</a></li>
</ul>
<p>底层 Pebble 引擎通过前缀压缩来保证 key 的高效存储。</p>
<h4 id="LSM-tree"><a href="#LSM-tree" class="headerlink" title="LSM tree"></a>LSM tree</h4><p>pebble 使用lsm tree 来管理数据存储。LSM tree 是一个层次树。在树的每一层，有对应的在磁盘上的文件来存储数据。这些文件叫做 SST 文件（sorted string table）。</p>
<h5 id="SSTs"><a href="#SSTs" class="headerlink" title="SSTs"></a>SSTs</h5><p>SST 是 key- value对 排序列表的磁盘表示。 </p>
<p>SST文件上不可变的，他们不会被修改，即使在 compaction 进程中。</p>
<h5 id="LSM-levels"><a href="#LSM-levels" class="headerlink" title="LSM levels"></a>LSM levels</h5><p>LSM tree 被组织为 L0 到 L6 层。L0上最顶层，L6是最底层。新数据是被添加到 L0层，然后随时间被 merged 到底层。</p>
<p>LSM tree 的每一层都有 SSTs 的集合，每个 SST 是不可变的并且是唯一的，序号是单调递增的。</p>
<p>每个一层的 SST 的 key 不会重叠：例如 如果一个 SST 包含key [A-F] ，下一个文件包含 [F-R]。但是 L0是特殊的，L0是唯一一层可以包含重叠的 keys 。由于以下原因，这种例外是必要的：</p>
<ul>
<li>为了使 基于LSM tree 的存储引擎，比如 pebble 支持大量数据的摄取，比如当使用 IMPORT 语句的时候。</li>
<li>为了使 memtales 更容易和高效的 flushes。</li>
</ul>
<h5 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h5><p>merging SSTs 文件并且从 L0移动到 L6到过程叫做 compaction，存储引擎compact 数据越快越好。这个过程的结果使得底层的包含更大的 SSTs文件，并且包含较少的最近更新的 keys。</p>
<p>compaction 过程是必要的为了使 LSM 更加高效； 从 L0到 L6，每一层应该包含下一层大约十分之一的数据。比如，L1大约有L2十分之一的数据。理想情况下，尽可能多的数据将存储在 LSM 较低级别引用的较大 SST 中。如果 compaction 过程落后，可能导致 inverted LSM。</p>
<p>SST 文件在压缩过程中永远不会被修改。 相反，新的 SST 被写入，旧的 SST 被删除。 这种设计利用了顺序磁盘访问比随机磁盘访问快得多的事实。</p>
<p>压缩的过程是这样的：如果需要合并两个 SST 文件 A 和 B，则将它们的内容（键值对）读入内存。 内容在内存中进行排序和合并，然后打开一个新文件 C 并将其写入磁盘，其中包含新的、更大的键值对排序列表。 此步骤在概念上类似于归并排序。 最后，旧文件 A 和 B 被删除。</p>
<h5 id="inverted-LSMs"><a href="#inverted-LSMs" class="headerlink" title="inverted LSMs"></a>inverted LSMs</h5><p>如果压缩过程落后于添加的数据量，并且树的更高层存储的数据多于下面的层级，则 LSM 形状可能会反转。</p>
<p>反向 LSM 会降低读取性能。</p>
<p>反向LSM 的读放大很高，在倒置 LSM 状态下，读取需要从更高级别开始，并通过大量 SST“向下看”以读取key的正确（最新）值。 当存储引擎需要从多个 SST 文件中读取以服务于单个逻辑读取时，这种状态称为读取放大。</p>
<p>如果大量的 IMPORT 使集群过载（由于 CPU 和&#x2F;或 IOPS 不足）并且存储引擎必须咨询 L0 中的许多小型 SST 以确定正在使用的键的最新值，则读取放大可能会特别糟糕。（例如，使用 SELECT）。</p>
<p>写放大比读放大更复杂，但可以广义地定义为：“我在压缩期间重写了多少物理文件？” 例如，如果存储引擎在 L5 中进行大量压缩，它将一遍又一遍地重写 L5 中的 SST 文件。 这是一个折衷，因为如果引擎没有足够频繁地执行压缩，L0 的大小会变得太大，并且会导致反向 LSM，这也会产生不良影响。</p>
<p>读取放大和写入放大是 LSM 性能的关键指标。 两者都不是天生的“好”或“坏”，但它们不能过度出现，并且为了获得最佳性能，它们必须保持平衡。 这种平衡涉及权衡。</p>
<p>倒置的 LSM 也有过多的压实债务。 在这种状态下，存储引擎有大量的压缩积压要做，以使反转的 LSM 恢复到正常的非反转状态。</p>
<p>有关如何监控集群的 LSM 运行状况的说明，请参阅 LSM 运行状况。 要监控集群的 LSM L0 运行状况，请参阅 LSM L0 运行状况。</p>
<h5 id="Memtable和wal"><a href="#Memtable和wal" class="headerlink" title="Memtable和wal"></a>Memtable和wal</h5><p>为了便于管理 LSM 树结构，存储引擎维护 LSM 的内存表示，称为 memtable； 内存表中的数据会定期刷新到磁盘上的 SST 文件中。</p>
<p>磁盘上另一个名为 write-ahead log（以下称为 WAL）的文件与每个 memtable 相关联，以确保在断电或其他故障的情况下的持久性。 WAL 是复制层向存储引擎发布的最新更新存储在磁盘上的位置。 每个 WAL 与一个 memtable 是一一对应的； 它们保持同步，并且作为存储引擎正常操作的一部分，来自 WAL 和 memtable 的更新会定期写入 SST。</p>
<p> 新值在写入memtable的同时写入 WAL。 它们最终会从 memtable 写入磁盘上的 SST 文件以进行长期存储。</p>
<h5 id="LSM-设计的权衡"><a href="#LSM-设计的权衡" class="headerlink" title="LSM 设计的权衡"></a>LSM 设计的权衡</h5><p>LSM 树设计优化了写入性能而不是读取性能。 通过将排序的键值数据保存在 SST 中，可以避免写入时的随机磁盘寻道。 它试图通过从 LSM 树中尽可能低的位置、从更少、更大的文件中进行读取来降低读取（随机搜索）的成本。 这就是存储引擎执行压缩的原因。 存储引擎还尽可能使用块缓存来进一步加快读取速度。</p>
<p>LSM 设计中的权衡是为了利用现代磁盘的工作方式，因为即使它们由于缓存提供了对磁盘上随机位置的更快读取，但它们在写入随机位置时的性能仍然相对较差。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>CockroachDB 严重依赖多版本并发控制（MVCC）来处理并发请求并保证一致性。 大部分工作是通过使用混合逻辑时钟 (HLC) 时间戳来区分数据版本、跟踪提交时间戳和识别值的垃圾收集到期来完成的。 然后，所有这些 MVCC 数据都存储在 Pebble 中。</p>
<p>尽管在存储层中实现，但 MVCC 值被广泛用于在事务层中强制执行一致性。 例如，CockroachDB 维护一个时间戳缓存，它存储最后一次读取密钥的时间戳。 如果写入操作发生的时间戳低于读取时间戳缓存中的最大值，则表示存在潜在异常，事务必须在稍后的时间戳重新启动。</p>
<h4 id="Time-travel"><a href="#Time-travel" class="headerlink" title="Time-travel"></a>Time-travel</h4><p>如 SQL:2011 标准中所述，CockroachDB 支持时间旅行查询（由 MVCC 启用）。</p>
<p>为此，所有模式信息背后也有一个类似 MVCC 的模型。 这使您可以执行 SELECT…AS OF SYSTEM TIME，CockroachDB 使用当时的模式信息来制定查询。</p>
<p>使用这些工具，您可以从数据库中获得一致的数据在垃圾回收之前。</p>
<h3 id="Garbage-collection"><a href="#Garbage-collection" class="headerlink" title="Garbage collection"></a>Garbage collection</h3><p>CockroachDB 定期垃圾收集 MVCC 值以减少存储在磁盘上的数据大小。 为此，当有一个较新的 MVCC 值具有比垃圾回收期更早的时间戳时，我们会压缩旧的 MVCC 值。 通过配置 gc.ttlseconds 复制区域变量，可以在集群、数据库或表级别设置垃圾收集周期。 </p>
<h4 id="Protected-timestamps"><a href="#Protected-timestamps" class="headerlink" title="Protected timestamps"></a>Protected timestamps</h4><p>垃圾收集只能在不受保护的时间戳覆盖的 MVCC 值上运行。 受保护的时间戳子系统的存在是为了确保依赖历史数据的操作的安全性，例如：</p>
<ul>
<li><a href="https://www.cockroachlabs.com/docs/v21.2/import">Imports</a>, including <a href="https://www.cockroachlabs.com/docs/v21.2/import-into"><code>IMPORT INTO</code></a></li>
<li><a href="https://www.cockroachlabs.com/docs/v21.2/backup">Backups</a></li>
<li><a href="https://www.cockroachlabs.com/docs/v21.2/change-data-capture-overview">Changefeeds</a></li>
<li><a href="https://www.cockroachlabs.com/docs/v21.2/online-schema-changes">Online schema changes</a></li>
</ul>
<p>受保护的时间戳可确保历史数据的安全性，同时还可以实现更短的 GC TTL。 较短的 GC TTL 意味着保留较少的先前 MVCC 值。 这有助于降低全天频繁更新行的工作负载的查询执行成本，因为 SQL 层必须扫描以前的 MVCC 值才能找到行的当前值。</p>
<h5 id="How-protected-timestamps-work"><a href="#How-protected-timestamps-work" class="headerlink" title="How protected timestamps work"></a>How protected timestamps work</h5><p>保护时间戳通过在内部系统表中创建记录来工作。当一个长时间运行的 job ，比如备份想要保护某个时间戳的数据不被 GC 时，他会创建改数据和时间戳关联的 记录。</p>
<p>成功创建保护记录后，时间戳小于或等于受保护时间戳的指定数据的 MVCC 值将不会被垃圾收集。 当创建保护记录的作业完成其工作时，它会删除该记录，从而允许垃圾收集器在以前受保护的值上运行。</p>
<h2 id="Transaction-contention-争用"><a href="#Transaction-contention-争用" class="headerlink" title="Transaction contention(争用)"></a>Transaction contention(争用)</h2><p>对相同索引键值进行操作的事务（特别是对给定索引键在相同列族上进行操作的事务）被严格序列化以遵守事务隔离语义。 为了保持这种隔离，编写事务“锁定”行以防止与并发事务的危险交互。 但是，如果多个事务试图同时访问相同的“锁定”数据，锁定可能会导致处理延迟。 这称为事务（或锁）争用。</p>
<p>当满足以下三个条件时，就会发生事务争用：</p>
<ul>
<li>有多个并发事务或语句（由同时连接到单个 CockroachDB 集群的多个客户端发送）。</li>
<li>它们对具有相同索引键值（主键或二级索引）的表行进行操作。</li>
<li>至少一个事务修改数据。</li>
</ul>
<p>经历争用的事务通常会延迟完成或重新启动。 事务重启的可能性需要客户端实现事务重试。</p>
<h3 id="Find-transaction-contention"><a href="#Find-transaction-contention" class="headerlink" title="Find transaction contention"></a>Find transaction contention</h3><p>查找事务中发生争用的事务和语句。 CockroachDB 有几个工具可以帮助您追踪此类事务和语句：</p>
<ul>
<li>在 DB Console 中，访问事务和语句页面并按争用对事务和语句进行排序。</li>
<li>查询数据库的 crdb_internal.cluster_contended_indexes 和 crdb_internal.cluster_contended_tables 表，以查找发生争用的索引和表。</li>
</ul>
<h3 id="Reduce-transaction-contention"><a href="#Reduce-transaction-contention" class="headerlink" title="Reduce transaction contention"></a>Reduce transaction contention</h3><p>为了减少事务争用：</p>
<ul>
<li>让事务更小，让每个事务做的工作更少。 特别是，避免每个事务进行多次客户端-服务器交换。 例如，使用公用表表达式将多个 SELECT 和 INSERT、UPDATE、DELETE 和 UPSERT 子句组合到一个 SQL 语句中。</li>
<li>一次性发送事务中的所有语句，以便 CockroachDB 自动为您重试事务。</li>
<li>在事务执行读取然后更新它刚刚读取的行的情况下使用 SELECT FOR UPDATE 语句。 该语句通过控制对表的一行或多行的并发访问来对事务进行排序。 它通过锁定选择查询返回的行来工作，这样试图访问这些行的其他事务被迫等待锁定这些行的事务完成。 这些其他事务被有效地放入队列中，该队列根据它们何时尝试读取锁定行的值进行排序。</li>
<li>替换行中的值时，使用 UPSERT 并为插入行中的所有列指定值。 与 SELECT、INSERT 和 UPDATE 的组合相比，这通常在争用情况下具有最佳性能。</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p>CockroachDB 支持将多个 SQL 语句捆绑到单个全有或全无事务中。 每个事务保证 ACID 语义跨越任意表和行，即使数据是分布式的。 如果事务成功，则所有突变都将与虚拟同时一起应用。 如果事务的任何部分失败，则整个事务将中止，并且数据库保持不变。 CockroachDB 保证当一个事务处于挂起状态时，它与其他具有可序列化隔离的并发事务隔离。</p>
<p>有关 CockroachDB 事务语义的详细讨论，请参阅 <a href="https://www.cockroachlabs.com/blog/how-cockroachdb-distributes-atomic-transactions/">https://www.cockroachlabs.com/blog/how-cockroachdb-distributes-atomic-transactions/</a> 和  <a href="https://www.cockroachlabs.com/blog/serializable-lockless-distributed-isolation-cockroachdb/">https://www.cockroachlabs.com/blog/serializable-lockless-distributed-isolation-cockroachdb/</a> 这篇博文中描述的事务模型的解释有些过时了。 有关更多详细信息，请参阅事务重试部分。</p>
<h3 id="SQL-statements"><a href="#SQL-statements" class="headerlink" title="SQL statements"></a>SQL statements</h3><table>
<thead>
<tr>
<th>Statement</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/begin-transaction"><code>BEGIN</code></a></td>
<td>Initiate a transaction, as well as control its <a href="https://www.cockroachlabs.com/docs/v22.1/transactions#transaction-priorities">priority</a>.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/set-transaction"><code>SET TRANSACTION</code></a></td>
<td>Control a transaction’s <a href="https://www.cockroachlabs.com/docs/v22.1/transactions#transaction-priorities">priority</a>.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/commit-transaction"><code>COMMIT</code></a></td>
<td>Commit a regular transaction, or clear the connection after committing a transaction using the <a href="https://www.cockroachlabs.com/docs/v22.1/advanced-client-side-transaction-retries">advanced retry protocol</a>.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/rollback-transaction"><code>ROLLBACK</code></a></td>
<td>Abort a transaction and roll the database back to its state before the transaction began.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/show-vars"><code>SHOW</code></a></td>
<td>Display the current transaction settings.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/savepoint"><code>SAVEPOINT</code></a></td>
<td>Used for <a href="https://www.cockroachlabs.com/docs/v22.1/transactions#nested-transactions">nested transactions</a>; also used to implement <a href="https://www.cockroachlabs.com/docs/v22.1/advanced-client-side-transaction-retries">advanced client-side transaction retries</a>.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/release-savepoint"><code>RELEASE SAVEPOINT</code></a></td>
<td>Commit a <a href="https://www.cockroachlabs.com/docs/v22.1/transactions#nested-transactions">nested transaction</a>; also used for <a href="https://www.cockroachlabs.com/docs/v22.1/advanced-client-side-transaction-retries">retryable transactions</a>.</td>
</tr>
<tr>
<td><a href="https://www.cockroachlabs.com/docs/v22.1/rollback-transaction"><code>ROLLBACK TO SAVEPOINT</code></a></td>
<td>Roll back a <a href="https://www.cockroachlabs.com/docs/v22.1/transactions#nested-transactions">nested transaction</a>; also used to handle <a href="https://www.cockroachlabs.com/docs/v22.1/advanced-client-side-transaction-retries">retryable transaction errors</a>.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>从零写数据库系列-parser</title>
    <url>/2023/02/01/2-%E6%95%B0%E6%8D%AE%E5%BA%93/3-%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%E9%9B%B6%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B03-parser/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统之进程</title>
    <url>/2023/01/31/0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>


]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解raft</title>
    <url>/2023/01/31/7-%E5%88%86%E5%B8%83%E5%BC%8F/raft/</url>
    <content><![CDATA[<span id="more"></span>



]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>学习方法</title>
    <url>/2023/06/09/6-%E9%97%B2%E8%B0%88/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>平时突然感悟到的学习方法。</p>
<span id="more"></span>







]]></content>
      <categories>
        <category>方法</category>
      </categories>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 基本分析工具</title>
    <url>/2023/01/31/8-linux/Linux%20%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<span id="more"></span>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
</search>
