<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/leoric.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="十年生死两茫茫，写代码，到天亮。">
<meta property="og:type" content="website">
<meta property="og:title" content="Leoirc&#39;s Blogs">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Leoirc&#39;s Blogs">
<meta property="og:description" content="十年生死两茫茫，写代码，到天亮。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Leoric">
<meta property="article:tag" content="数据库 C++ go">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Leoirc's Blogs</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Leoirc's Blogs</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Leoric"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Leoric</p>
  <div class="site-description" itemprop="description">十年生死两茫茫，写代码，到天亮。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Heoric" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Heoric" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">设计模式之设计原则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 14:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T14:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:33:18" itemprop="dateModified" datetime="2023-08-19T15:33:18+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><ul>
<li><p>高层模块（稳定）不应该依赖底层模块（变化），二者都应该依赖于抽象（稳定）。</p>
</li>
<li><p>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</p>
</li>
</ul>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><ul>
<li><p>对拓展开放，对更改封闭。</p>
</li>
<li><p>类模块应该是可拓展的，但是不可修改。</p>
</li>
</ul>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><ul>
<li>一个类应该仅有一个引起它变化的原因。</li>
<li>变化的方向隐含着类的责任。</li>
</ul>
<h3 id="Liskov-替换原则（LSP）"><a href="#Liskov-替换原则（LSP）" class="headerlink" title="Liskov 替换原则（LSP）"></a>Liskov 替换原则（LSP）</h3><ul>
<li>子类必须能够体会他们的基类（IS-A）。</li>
<li>继承表达类型抽象。</li>
</ul>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><ul>
<li><p>不应该强迫客户程序依赖他们不用的方法</p>
</li>
<li><p>接口应该小而完备</p>
</li>
</ul>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><ul>
<li>类继承通常为 “白箱复用”，对象组合通常为 “黑箱复用”。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合性高。</li>
</ul>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00-%E6%A6%82%E8%BF%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" class="post-title-link" itemprop="url">设计模式之简单工厂模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 14:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T14:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:04:59" itemprop="dateModified" datetime="2023-08-19T15:04:59+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/7-%E5%88%86%E5%B8%83%E5%BC%8F/cap%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/7-%E5%88%86%E5%B8%83%E5%BC%8F/cap%20/" class="post-title-link" itemprop="url">理解分布式 cap 理论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 14:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T14:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:14:01" itemprop="dateModified" datetime="2023-08-19T15:14:01+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="CAP理论概述"><a href="#CAP理论概述" class="headerlink" title="CAP理论概述"></a>CAP理论概述</h3><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/7-%E5%88%86%E5%B8%83%E5%BC%8F/cap%20/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/2-%E6%95%B0%E6%8D%AE%E5%BA%93/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/2-%E6%95%B0%E6%8D%AE%E5%BA%93/template/" class="post-title-link" itemprop="url">数据库SQL总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 14:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T14:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-20 09:44:50" itemprop="dateModified" datetime="2023-08-20T09:44:50+08:00">2023-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据库、操作系统和编译器是计算机软件的三大系统。其中数据库更接近业务层，几乎所有软件都会用到数据库，所以对数据库的熟练使用时每个开发人员必备的技能，而数据库对外最直接的接口就是 SQL。</p>
<p>今天我们来讲讲数据库SQL。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/2-%E6%95%B0%E6%8D%AE%E5%BA%93/template/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/4-go/go%20channel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/4-go/go%20channel/" class="post-title-link" itemprop="url">go channel 用法及原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 10:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T10:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:02:14" itemprop="dateModified" datetime="2023-08-19T15:02:14+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="无缓冲"><a href="#无缓冲" class="headerlink" title="无缓冲"></a>无缓冲</h2><p>创建一个channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chan1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>



<h2 id="有缓冲"><a href="#有缓冲" class="headerlink" title="有缓冲"></a>有缓冲</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chan2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/4-go/go%20channel/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/4-go/go%20context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/4-go/go%20context/" class="post-title-link" itemprop="url">go context 原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 10:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T10:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:01:04" itemprop="dateModified" datetime="2023-08-19T15:01:04+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文 <a target="_blank" rel="noopener" href="https://go.dev/blog/context">https://go.dev/blog/context</a></p>
<p><a target="_blank" rel="noopener" href="https://go.dev/blog/pipelines">https://go.dev/blog/pipelines</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在 Go 服务器中，每个传入的请求都在其自己的 goroutine 中处理。 </p>
<p>请求处理程序通常会启动额外的 goroutine 来访问后台，比如数据库和 RPC 服务等。</p>
<p> 处理请求的 goroutines 集通常需要访问特定于请求的值，例如最终用户的身份、授权令牌和请求的截止日期。</p>
<p> 当请求被取消或超时时，所有处理该请求的 goroutines 都应该快速退出，以便系统可以回收它们正在使用的任何资源。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/4-go/go%20context/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/4-go/go%20%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/4-go/go%20%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">go 闭包现象和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 10:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T10:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-03 14:01:34" itemprop="dateModified" datetime="2023-02-03T14:01:34+08:00">2023-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/4-go/go%20%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/31/4-go/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/31/4-go/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">go 接口原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-31 10:44:57" itemprop="dateCreated datePublished" datetime="2023-01-31T10:44:57+08:00">2023-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-19 15:02:48" itemprop="dateModified" datetime="2023-08-19T15:02:48+08:00">2023-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/%E8%AE%BA%E6%96%87/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/21/%E8%AE%BA%E6%96%87/1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-21 16:59:31" itemprop="dateCreated datePublished" datetime="2022-01-21T16:59:31+08:00">2022-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-20 17:36:02" itemprop="dateModified" datetime="2023-07-20T17:36:02+08:00">2023-07-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Everything-You-Always-Wanted-to-Know-About-Compiled-and-Vectorized-Queries-But-Were-Afraid-to-Ask"><a href="#Everything-You-Always-Wanted-to-Know-About-Compiled-and-Vectorized-Queries-But-Were-Afraid-to-Ask" class="headerlink" title="Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask"></a><strong>Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask</strong></h2><p><strong>您一直想了解但又不敢问的有关编译和矢量化查询的所有信息</strong></p>
<h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>The query engines of most modern database systems are either based on vectorization or data-centric code generation. These two state-of-the-art query processing paradigms are fundamentally dif- ferent in terms of system structure and query execution code. Both paradigms were used to build fast systems. However, until today it is not clear which paradigm yields faster query execution, as many implementation-specific choices obstruct a direct comparison of ar- chitectures. In this paper, we experimentally compare the two mod- els by implementing both within the same test system. This allows us to use for both models the same query processing algorithms, the same data structures, and the same parallelization framework to ul- timately create an apples-to-apples comparison. We find that both are efficient, but have different strengths and weaknesses. Vector- ization is better at hiding cache miss latency, whereas data-centric compilation requires fewer CPU instructions, which benefits cache- resident workloads. Besides raw, single-threaded performance, we also investigate SIMD as well as multi-core parallelization and dif- ferent hardware architectures. Finally, we analyze qualitative dif- ferences as a guide for system architects.</p>
<p>大多数现代数据库系统的查询引擎要么基于矢量化，要么基于以数据为中心的代码生成。 这两种最先进的查询处理范例在系统结构和查询执行代码方面有着根本的不同。 这两种范例都用于构建快速系统。 然而，直到今天还不清楚哪种范例可以产生更快的查询执行，因为许多特定于实现的选择阻碍了架构的直接比较。 在本文中，我们通过在同一测试系统中实现这两个模型来对这两个模型进行实验比较。 这使我们能够对两个模型使用相同的查询处理算法、相同的数据结构和相同的并行化框架，以最终创建同类比较。 我们发现两者都很有效，但有不同的优点和缺点。 矢量化可以更好地隐藏缓存未命中延迟，而以数据为中心的编译需要更少的 CPU 指令，这有利于缓存驻留的工作负载。 除了原始的单线程性能之外，我们还研究了 SIMD 以及多核并行化和不同的硬件架构。 最后，我们分析定性差异，作为系统架构师的指南。</p>
<h3 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h3><p>In most query engines, each relational operator is implemented using Volcano-style iteration [14]. While this model worked well in the past when disk was the primary bottleneck, it is inefficient on modern CPUs for in-memory database management systems (DBMSs). Most modern query engines therefore either use <em>vec- torization</em> (pioneered by VectorWise [7, 52]) or <em>data-centric code generation</em> (pioneered by HyPer [28]). Systems that use vector- ization include DB2 BLU [40], columnar SQL Server [21], and Quickstep [33], whereas systems based on data-centric code gener- ation include Apache Spark [2] and Peloton [26].</p>
<p>在大多数查询引擎中，每个关系运算符都是使用火山式迭代来实现的[14]。 虽然这种模型在过去磁盘是主要瓶颈时运行良好，但在内存数据库管理系统 (DBMS) 的现代 CPU 上效率较低。 因此，大多数现代查询引擎要么使用矢量化（由 VectorWise [7, 52] 首创），要么使用以数据为中心的代码生成（由 HyPer [28] 首创）。 使用矢量化的系统包括 DB2 BLU [40]、列式 SQL Server [21] 和 Quickstep [33]，而基于以数据为中心的代码生成的系统包括 Apache Spark [2] 和 Peloton [26]。</p>
<p>Like the Volcano-style iteration model, vectorization uses pull- based iteration where each operator has a <em>next</em> method that produces result tuples. However, each <em>next</em> call fetches a block of tuples instead of just one tuple, which amortizes the iterator call over- head. The actual query processing work is performed by primitives that execute a simple operation on one or more type-specialized columns (e.g., compute hashes for a vector of integers). Together, amortization and type specialization eliminate most of the overhead of traditional engines.</p>
<p>与火山式迭代模型一样，矢量化使用基于拉的迭代，其中每个运算符都有一个生成结果元组的 next 方法。 然而，接下来的每个调用都会获取一组元组而不是仅仅一个元组，这会分摊迭代器调用开销。 实际的查询处理工作是由对一个或多个类型专用列执行简单操作的原语执行的（例如，计算整数向量的哈希值）。 摊销和类型专业化共同消除了传统发动机的大部分开销。</p>
<p>In data-centric code generation, each relational operator imple- ments a push-based interface (<em>produce</em> and <em>consume</em>). However, in- stead of directly processing tuples, the produce&#x2F;consume calls gen- erate code for a given query. They can also be seen as operator methods that get called during a depth-first traversal of the query plan tree, where produce is called on first visit, and consume on last visit, after all children have been processed. The resulting code is specialized for the data types of the query and fuses all operators in a pipeline of non-blocking relational operators into a single (po- tentially nested) loop. This generated code can then be compiled to efficient machine code (e.g., using the LLVM).</p>
<p>在以数据为中心的代码生成中，每个关系运算符都实现一个基于推送的接口（生产和消费）。 然而，生产&#x2F;消费调用不是直接处理元组，而是为给定的查询生成代码。 它们也可以被视为在查询计划树的深度优先遍历期间调用的运算符方法，其中在第一次访问时调用 Produce，并在处理完所有子级后在最后一次访问时调用 Consumer。 生成的代码专门针对查询的数据类型，并将非阻塞关系运算符管道中的所有运算符融合到单个（可能是嵌套的）循环中。 然后可以将生成的代码编译为高效的机器代码（例如，使用 LLVM）。</p>
<p>Although both models eliminate the overhead of traditional en- gines and are highly efficient, they are conceptually different from each other: Vectorization is based on the pull model (root-to-leaf traversal), vector-at-a-time processing, and interpretation. Data- centric code generation uses the push model (leaf-to-root traver- sal), tuple-at-a-time processing, and up-front compilation. As we discuss in Section 9, other designs that mix or combine ideas from data-centric compilation and vectorization have been proposed. In this paper, we focus on these two specific designs, as they have been highly influential and are in use in multiple widespread systems.</p>
<p>尽管这两种模型都消除了传统引擎的开销并且效率很高，但它们在概念上有所不同：矢量化基于拉模型（根到叶遍历）、一次矢量处理和 解释。 以数据为中心的代码生成使用推送模型（叶到根遍历）、一次元组处理和预先编译。 正如我们在第 9 节中讨论的，已经提出了混合或结合以数据为中心的编译和矢量化思想的其他设计。 在本文中，我们重点关注这两种具体设计，因为它们具有很大的影响力并且在多个广泛的系统中使用。</p>
<p>The differences of the two models are fundamental and deter- mine the organization of the DBMS’s execution engine source code and its performance characteristics. Because changing the model requires rewriting large parts of the source code, DBMS design- ers must decide early on which model to use. Looking at recent DBMS developments like Quickstep [33] and Peloton [26], we find that both choices are popular and plausible: Quickstep is based on vectorization, Peloton uses data-centric code generation.</p>
<p>两种模型的差异是根本性的，决定了 DBMS 执行引擎源代码的组织及其性能特征。 由于更改模型需要重写大部分源代码，因此 DBMS 设计人员必须尽早决定使用哪个模型。 看看最近的 DBMS 开发，例如 Quickstep [33] 和 Peloton [26]，我们发现这两种选择都很流行且合理：Quickstep 基于矢量化，Peloton 使用以数据为中心的代码生成。</p>
<p>Given the importance of this choice, it is surprising that there has not yet been a systematic study comparing the two state-of-the- art query processing models. In this paper, we provide an in-depth experimental comparison of the two models to understand when a database architect should prefer one model over the other.</p>
<p>考虑到这种选择的重要性，令人惊讶的是还没有系统的研究来比较这两种最先进的查询处理模型。 在本文中，我们对这两种模型进行了深入的实验比较，以了解数据库架构师何时应该更喜欢一种模型而不是另一种模型。</p>
<p>To compare vectorization and compilation, one could compare the runtime performance of emblematic DBMSs, such as HyPer and VectorWise. The problem is, however, that such full-featured DBMSs differ in many design dimensions beyond the query execu- tion model. For instance, HyPer does not employ sub-byte compression in its columnar storage [19], whereas VectorWise uses more compact compression methods [53]. Related to this choice, HyPer features predicate-pushdown in scans but VectorWise does not. Another important dimension in which both systems differ is parallelism. VectorWise queries spawn threads scheduled by the OS, and controls parallelism using explicit exchange opera- tors where the parallelism degree is fixed at query optimization time [3]. HyPer, on the other hand, runs one thread on each core and explicitly schedules query tasks on it on a morsel-driven basis using a NUMA-aware, lock-free queue to distribute work. HyPer and VectorWise also use different query processing algorithms and structures, data type representations, and query optimizers. Such different design choices affect performance and scalability, but are independent of the query execution model.</p>
<p>为了比较矢量化和编译，可以比较代表性 DBMS（例如 HyPer 和 VectorWise）的运行时性能。 然而问题是，这种全功能的 DBMS 在查询执行模型之外的许多设计维度上都有所不同。 例如，HyPer 在其列式存储中不采用子字节压缩 [19]，而 VectorWise 使用更紧凑的压缩方法 [53]。 与此选择相关的是，HyPer 在扫描中具有谓词下推功能，但 VectorWise 则没有。 两个系统不同的另一个重要方面是并行性。 VectorWise 查询产生由操作系统调度的线程，并使用显式交换运算符控制并行性，其中并行度在查询优化时固定[3]。 另一方面，HyPer 在每个核心上运行一个线程，并使用 NUMA 感知、无锁队列来分配工作，在少量驱动的基础上显式地调度查询任务。 HyPer 和 VectorWise 还使用不同的查询处理算法和结构、数据类型表示和查询优化器。 这种不同的设计选择会影响性能和可伸缩性，但与查询执行模型无关。</p>
<p>To isolate the fundamental properties of the execution model from incidental differences, we implemented a compilation-based relational engine and a vectorization-based engine in a single test system (available at [16]). The experiments where we employed data-centric code-generation into C++1 we call “Typer” and the vectorized engine we call ”Tectorwise” (TW). Both implementa- tions use the same algorithms and data structures. This allows an apples-to-apples comparison of both approaches because the only difference between Tectorwise and Typer is the query execution method: vectorized versus data-centric compiled execution.</p>
<p>为了将执行模型的基本属性与偶然差异隔离开来，我们在单个测试系统中实现了基于编译的关系引擎和基于向量化的引擎（可在[16]中找到 <a target="_blank" rel="noopener" href="https://github.com/TimoKersten/db-engine-paradigms%EF%BC%89%E3%80%82">https://github.com/TimoKersten/db-engine-paradigms）。</a> 我们在 C++1 中采用以数据为中心的代码生成的实验称为“Typer”，矢量化引擎称为“Tectorwise”(TW)。 两种实现都使用相同的算法和数据结构。 这允许对两种方法进行同类比较，因为 Tectorwise 和 Typer 之间的唯一区别是查询执行方法：矢量化与以数据为中心的编译执行。</p>
<p>Our experimental results show that both approaches lead to very efficient execution engines, and the performance differences are generally not very large. Compilation-based engines have an ad- vantage in calculation-heavy queries, whereas vectorized engines are better at hiding cache miss latency, e.g., during hash joins.</p>
<p>我们的实验结果表明，这两种方法都会产生非常高效的执行引擎，并且性能差异通常不是很大。 基于编译的引擎在计算量大的查询中具有优势，而矢量化引擎更擅长隐藏缓存未命中延迟，例如在散列连接期间。</p>
<p>After introducing the two models in more detail in Section 2 and describing our methodology in Section 3, we perform a micro- architectural analysis of in-memory OLAP workloads in Section 4. We then examine in Section 5 the benefit of data-parallel opera- tions (SIMD), and Section 6 discusses intra-query parallelization on multi-core CPUs. In Section 7, we investigate different hard- ware platforms (Intel, AMD, Xeon Phi) to find out which model works better on which hardware. After these quantitative OLAP performance comparisons, we discuss other factors in Section 8, including OLTP workloads and compile time. A discussion of hy- brid processing models follows in Section 9. We conclude by sum- marizing our results as a guide for system designers in Section 10.</p>
<p>在第 2 节中更详细地介绍了这两个模型并在第 3 节中描述了我们的方法之后，我们在第 4 节中对内存中 OLAP 工作负载进行了微架构分析。然后，我们在第 5 节中研究了数据并行操作的好处。 （SIMD），第 6 节讨论多核 CPU 上的查询内并行化。 在第 7 节中，我们研究了不同的硬件平台（Intel、AMD、Xeon Phi），以找出哪种模型在哪种硬件上运行得更好。 在这些定量的 OLAP 性能比较之后，我们将在第 8 节中讨论其他因素，包括 OLTP 工作负载和编译时间。 第 9 节对混合处理模型进行了讨论。最后，我们总结了我们的结果，作为第 10 节中系统设计者的指南。</p>
<h3 id="2-VECTORIZED-VS-COMPILED-QUERIES"><a href="#2-VECTORIZED-VS-COMPILED-QUERIES" class="headerlink" title="2. VECTORIZED VS. COMPILED QUERIES"></a>2. VECTORIZED VS. COMPILED QUERIES</h3><p>The main principle of vectorized execution is <em>batched</em> execu- tion [30] on a columnar data representation: every “work” prim- itive function that manipulates data does not work on a single data item, but on a vector (an array) of such data items that represents multiple tuples. The idea behind vectorized execution is to amor- tize the DBMS’s interpretation decisions by performing as much as possible inside the data manipulation methods. For example, this work can be to hash 1000s of values, compare 1000s of string pairs, update a 1000 aggregates, or fetch a 1000 values from 1000s of addresses.</p>
<p>向量化执行的主要原理是在列式数据表示上进行批量执行[30]：操作数据的每个“工作”原语函数并不作用于单个数据项，而是作用于这样的向量（数组）。 表示多个元组的数据项。 矢量化执行背后的想法是通过在数据操作方法内尽可能多地执行来分摊 DBMS 的解释决策。 例如，这项工作可以是散列 1000 个值、比较 1000 个字符串对、更新 1000 个聚合或从 1000 个地址中获取 1000 个值。</p>
<p>Data-centric compilation generates low-level code for a SQL query that fuses all adjacent non-blocking operators of a query pipeline into a single, tight loop. In order to understand the proper- ties of vectorized and compiled code, it is important to understand the structure of each variant’s code. Therefore, in this section we present example operator implementations, motivate why they are implemented in this fashion, and discuss some of their properties.</p>
<p>以数据为中心的编译为 SQL 查询生成低级代码，将查询管道的所有相邻非阻塞运算符融合到单个紧密循环中。 为了了解矢量化和编译代码的属性，了解每个变体代码的结构非常重要。 因此，在本节中，我们将介绍示例运算符实现，解释为什么以这种方式实现它们，并讨论它们的一些属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec&lt;<span class="type">int</span>&gt; <span class="title">sel_eq_row</span><span class="params">(vec&lt;string&gt; col, vec&lt;<span class="type">int</span>&gt; tir)</span> </span></span><br><span class="line"><span class="function">  vec&lt;<span class="type">int</span>&gt; res</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;col.<span class="built_in">size</span>(); i++) <span class="comment">// for colors and tires</span></span><br><span class="line">		<span class="keyword">if</span>(col[i] == <span class="string">&quot;green&quot;</span> &amp;&amp; tir[i] == <span class="number">4</span>) <span class="comment">// compare both </span></span><br><span class="line">      res.<span class="built_in">append</span>(i) <span class="comment">// add to final result</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">res</span></span><br><span class="line">			(a) Integrated: Both predicates checked at once</span><br><span class="line">      </span><br><span class="line">vec&lt;<span class="type">int</span>&gt; <span class="built_in">sel_eq_string</span>(vec&lt;string&gt; col, string o) </span><br><span class="line">      vec&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;col.<span class="built_in">size</span>(); i++) <span class="comment">// for colors</span></span><br><span class="line">				<span class="keyword">if</span>(col[i] == o) <span class="comment">// compare color </span></span><br><span class="line">          res.<span class="built_in">append</span>(i) <span class="comment">// remember position</span></span><br><span class="line">			<span class="keyword">return</span> res</span><br><span class="line">          </span><br><span class="line">vec&lt;<span class="type">int</span>&gt; <span class="built_in">sel_eq_int</span>(vec&lt;<span class="type">int</span>&gt; tir, <span class="type">int</span> o, vec&lt;<span class="type">int</span>&gt; s) </span><br><span class="line">          vec&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">					<span class="keyword">for</span>(i : s) <span class="comment">// for remembered position</span></span><br><span class="line">						<span class="keyword">if</span>(tir[i] == o) <span class="comment">// compare tires </span></span><br><span class="line">  					res.<span class="built_in">append</span>(i) <span class="comment">// add to final result</span></span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">res</span></span><br><span class="line">			(b) Vectorized: Each predicate checked in one primitive</span><br><span class="line">              </span><br><span class="line"><span class="comment">//图 1：多谓词示例 – 对一个数据项评估多个谓词的直接方法是一次检查所有谓词 (1a)。 </span></span><br><span class="line"><span class="comment">//矢量化代码必须将每个谓词的求值分成一个部分 (1b)。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-Vectorizing-Algorithms"><a href="#2-1-Vectorizing-Algorithms" class="headerlink" title="2.1 Vectorizing Algorithms"></a>2.1 Vectorizing Algorithms</h4><p>Typer executes queries by running generated code. This means that a developer can create operator implementations in any way they see fit. Consider the example in Figure 1a: a function that selects every row whose color is green and has four tires. There is a loop over all rows and in each iteration, all predicates are evaluated.</p>
<p>Typer 通过运行生成的代码来执行查询。 这意味着开发人员可以以他们认为合适的任何方式创建运算符实现。 考虑图 1a 中的示例：该函数选择颜色为绿色且有四个轮胎的每一行。 所有行都有一个循环，并且在每次迭代中，都会评估所有谓词。</p>
<p>Tectorwise implements the same algorithms as Typer, staying as close to it as possible and reasonable (for performance). This is, however, only possible to a certain degree, as every function imple- mented in vectorized style has two constraints: It can (i) only work on <em>one</em> data type2 and it (ii) must process multiple tuples. In gener- ated code these decisions can both be put into the expression of one if statement. This, however, violates (i) which forces Tectorwise to use two functions as shown in Figure 1b. A (not depicted) in- terpretation logic would start by running the first function to se- lect all elements by color, then the second function to select by number of tires. By processing multiple elements at a time, these functions also satisfy (ii). The dilemma is faced by all operators in Tectorwise and all functions are broken down into primitives that satisfy (i) and (ii). This example uses a column-wise storage format, but row-wise formats are feasible as well. To maximize throughput, database developers tend to highly optimize such func- tions. For example, with the help of predicated evaluation (*res&#x3D;i; res+&#x3D;cond) or SIMD vectorized instruction logic (see Section 5.1).</p>
<p>Tectorwise 实现了与 Typer 相同的算法，尽可能接近并合理（为了性能）。 然而，这仅在一定程度上是可能的，因为以矢量化风格实现的每个函数都有两个约束：它只能（i）仅适用于一种数据类型2，并且（ii）必须处理多个元组。 在生成的代码中，这些决策都可以放入一个 if 语句的表达式中。 然而，这违反了 (i)，这迫使 Tectorwise 使用两个函数，如图 1b 所示。 （未描述）解释逻辑将首先运行第一个函数以按颜色选择所有元素，然后运行第二个函数以按轮胎数量选择。 通过一次处理多个元素，这些函数也满足 (ii)。 Tectorwise 中的所有算子都面临着这样的困境，所有函数都被分解为满足 (i) 和 (ii) 的原语。 本示例使用列式存储格式，但行式格式也是可行的。 为了最大化吞吐量，数据库开发人员倾向于高度优化此类功能。 例如，借助谓词求值 (*res&#x3D;i; res+&#x3D;cond) 或 SIMD 向量化指令逻辑（参见第 5.1 节）。</p>
<p>With these constraints in mind, let us examine the details of op- erator implementations of Tectorwise. We implemented selections as shown above. Expressions are split by arithmetic operators into primitives in a similar fashion. Note that for these simple operators the Tectorwise implementation must already change the structure of the algorithms and deviate from the Typer data access patterns. The resulting materialization of intermediates makes fast caches very important for vectorized engines.</p>
<p>考虑到这些限制，让我们检查一下 Tectorwise 运算符实现的细节。 我们实施了如上所示的选择。 表达式被算术运算符以类似的方式分割为基元。 请注意，对于这些简单的运算符，Tectorwise 实现必须已经更改了算法的结构并偏离了 Typer 数据访问模式。 由此产生的中间物的具体化使得快速缓存对于矢量化引擎非常重要。</p>
<h4 id="2-2-Vectorized-Hash-Join-and-Group-By"><a href="#2-2-Vectorized-Hash-Join-and-Group-By" class="headerlink" title="2.2 Vectorized Hash Join and Group By"></a>2.2 Vectorized Hash Join and Group By</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">query</span>(...)</span><br><span class="line"><span class="comment">// build hash table</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) </span><br><span class="line">  ht.<span class="built_in">insert</span>(&lt;S.att1[i], S.att2[i]&gt;, S.att3[i])</span><br><span class="line"><span class="comment">// probe hash table</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; R.<span class="built_in">size</span>(); i++)</span><br><span class="line">	<span class="type">int</span> k1 = R.att1[i]</span><br><span class="line">	string* k2 = R.att2[i]</span><br><span class="line">	<span class="type">int</span> hash = <span class="built_in">hash</span>(k1, k2)</span><br><span class="line"><span class="keyword">for</span>(Entry* e = ht.<span class="built_in">find</span>(hash); e; e = e-&gt;next)</span><br><span class="line">	<span class="keyword">if</span>(e-&gt;key1 == k1 &amp;&amp; e-&gt;key2 == *k2) </span><br><span class="line">    ... <span class="comment">// code of parent operator</span></span><br><span class="line">		(a) Code generated <span class="keyword">for</span> hash join</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> HashJoin</span><br><span class="line">	Primitives probeHash_, compareKeys_, buildGather_; </span><br><span class="line">	...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HashJoin::next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">... <span class="comment">// consume build side and create hash table </span></span></span><br><span class="line"><span class="function">    <span class="type">int</span> n </span>= probe-&gt;<span class="built_in">next</span>()<span class="comment">// get tuples from probe side </span></span><br><span class="line">    <span class="comment">// *Interpretation*: compute hashes</span></span><br><span class="line">		vec&lt;<span class="type">int</span>&gt; hashes = probeHash_.<span class="built_in">eval</span>(n)</span><br><span class="line">		<span class="comment">// find hash candidate matches 	for hashes </span></span><br><span class="line">    vec&lt;Entry*&gt; candidates = ht.<span class="built_in">findCandidates</span>(hashes) </span><br><span class="line">    <span class="comment">// matches: int references a position in hashes </span></span><br><span class="line">    vec&lt;Entry*, <span class="type">int</span>&gt; matches = &#123;&#125;</span><br><span class="line">		<span class="comment">// check candidates to find matches </span></span><br><span class="line">		<span class="keyword">while</span>(candidates.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">// *Interpretation*</span></span><br><span class="line">			vec&lt;<span class="type">bool</span>&gt; isEqual = compareKeys_.<span class="built_in">eval</span>(n, candidates) </span><br><span class="line">      hits, candidates = <span class="built_in">extractHits</span>(isEqual, candidates)</span><br><span class="line">      matches += hits</span><br><span class="line">		<span class="comment">// *Interpretation*: gather from hash table into </span></span><br><span class="line">   	<span class="comment">// buffers for next operator </span></span><br><span class="line">    buildGather_.<span class="built_in">eval</span>(matches)</span><br><span class="line">		<span class="keyword">return</span> matches.<span class="built_in">size</span>()</span><br><span class="line">      </span><br><span class="line">		(b) Vectorized code that performs a hash join</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"> 图 <span class="number">2</span>：Typer 和 Tectorwise 中的哈希连接实现 - 生成的代码（图 <span class="number">2</span>a）可以采用任何形式，</span><br><span class="line">      例如，它可以结合哈希表键的相等性检查。 在矢量化代码中（图 <span class="number">2b</span>），</span><br><span class="line">      这只能通过每次检查使用一个原语来实现。</span><br></pre></td></tr></table></figure>

<p>Pseudo code for parts of our hash join implementations are shown in Figure 2. The idea for both, the implementation in Typer and Tectorwise, is to first consume all tuples from one input and place them into a hash table. The entries are stored in row format for better cache locality. Afterwards, for each tuple from the other in- put, we probe the hash table and yield all found combinations to the parent operator. The corresponding code that Typer generates is depicted in Figure 2a.</p>
<p>图 2 显示了部分散列连接实现的伪代码。Typer 和 Tectorwise 中的实现的想法是首先消耗来自一个输入的所有元组并将它们放入散列表中。 条目以行格式存储，以获得更好的缓存位置。 然后，对于来自其他输入的每个元组，我们探测哈希表并将所有找到的组合生成给父运算符。 Typer 生成的相应代码如图 2a 所示。</p>
<p>Tectorwise cannot proceed in exactly the same manner. Probing a hash table with composite keys is the intricate part here, as each probe operation needs to test equality of all parts of the composite key. Using the former approach would, however, violate (i). There- fore, the techniques from Section 2.1 are applied: The join function first creates hashes from the probe keys. It does this by evaluating the probeHash expression. A user of the vectorized hash join must configure the probeHash and other expressions that belong to the operator so that when the expressions evaluate, they use data from the operator’s children. Here, the probeHash expression hashes key columns by invoking one primitive per key column and writes the hashes into an output vector. The join function then uses this vector of hashes to generate candidate match locations in the hash table. It then inspects all discovered locations and checks for key equality. It performs the equality check by evaluating the cmpKey expression. For composite join-keys, this invokes multiple primitives: one for every key column, to avoid violating (i) and (ii). Then, the join function adds the matches to the list of matching tuples, and, in case any candidates have an overflow chain, it uses the overflow entries as new candidates for the next iteration. The algorithm coninues until the candidate vector is empty. Afterwards, the join uses buildGather to move data from the hash table into buffers for the next operator.</p>
<p>Tectorwise 不能以完全相同的方式进行。 使用组合键探测哈希表是这里的复杂部分，因为每个探测操作都需要测试组合键所有部分的相等性。 然而，使用前一种方法会违反 (i)。 因此，应用了 2.1 节中的技术：连接函数首先根据探测键创建哈希值。 它通过评估probeHash 表达式来实现这一点。 矢量化哈希连接的用户必须配置probeHash和属于该运算符的其他表达式，以便在表达式求值时，它们使用来自该运算符子级的数据。 此处，probeHash 表达式通过为每个键列调用一个原语来对键列进行哈希处理，并将哈希值写入输出向量。 然后，连接函数使用该哈希向量在哈希表中生成候选匹配位置。 然后，它检查所有发现的位置并检查密钥是否相等。 它通过评估 cmpKey 表达式来执行相等性检查。 对于复合连接键，这会调用多个原语：每个键列一个原语，以避免违反 (i) 和 (ii)。 然后，join 函数将匹配项添加到匹配元组列表中，并且，如果任何候选项具有溢出链，它会使用溢出条目作为下一次迭代的新候选项。 该算法一直持续到候选向量为空为止。 然后，连接使用 buildGather 将数据从哈希表移动到缓冲区中以供下一个运算符使用。</p>
<p>We take a similar approach in the group by operator. Both phases of the aggregation use a hash table that contains group keys and aggregates. The first step for all inbound tuples is to find their group in the hash table. We perform this with the same technique as in the hash join. For those tuples whose group is not found, one must be added. Unfortunately, it is not sufficient to just add one group per group-less tuple as this could lead to groups added multiple times. We therefore shuffle all group-less tuples into partitions of equal keys (proceeding component by component for composite keys), and add one group per partition to the hash table. Once the groups for all incoming tuples are known we run aggregation primitives. Transforming into vectorized form led to an even greater deviation from Typer data access patterns. For the join operator, this leads to more independent data accesses (as discussed in Section 4.1). However, aggregation incurs extra work.</p>
<p>我们在按运算符分组时采用类似的方法。 聚合的两个阶段都使用包含组键和聚合的哈希表。 所有入站元组的第一步是在哈希表中找到它们的组。 我们使用与散列连接相同的技术来执行此操作。 对于那些没有找到组的元组，必须添加一个。 不幸的是，仅仅为每个无组元组添加一个组是不够的，因为这可能会导致多次添加组。 因此，我们将所有无组元组混入相同键的分区中（对于复合键，逐个组件进行），并将每个分区添加一个组到哈希表中。 一旦知道所有传入元组的组，我们就运行聚合原语。 转换为矢量化形式会导致与 Typer 数据访问模式的更大偏差。 对于连接运算符，这会导致更独立的数据访问（如第 4.1 节中所述）。 然而，聚合会带来额外的工作。</p>
<p>Note that in order to implement Tectorwise operators we need to deviate from the Typer implementations. This deviation is not by choice, but due to the limitations (i) and (ii) which vectorization imposes. This yields two different implementations for each oper- ator, but at its core, each operator executes the same algorithm with the same parallelization strategy.</p>
<p>请注意，为了实现 Tectorwise 运算符，我们需要偏离 Typer 实现。 这种偏差不是出于选择，而是由于矢量化所施加的限制 (i) 和 (ii)。 这为每个运算符产生了两种不同的实现，但其核心是每个运算符使用相同的并行化策略执行相同的算法。</p>
<h3 id="3-METHODOLOGY-方法"><a href="#3-METHODOLOGY-方法" class="headerlink" title="3. METHODOLOGY 方法"></a>3. METHODOLOGY 方法</h3><p>To isolate the fundamental properties of the execution model from incidental differences found in real-world systems, we im- plemented a compilation-based engine (Typer) and a vectorization- based engine (Tectorwise) in a single test system (available at [16]). To make experiments directly comparable, both implementations use the same algorithms and data structures. When testing queries, we use the same physical query plans for vectorized and compiled execution. We do not include query parsing, optimization, code generation, and compilation time in our measurements. This test- ing methodology allows an apples-to-apples comparison of both approaches because the only difference between Tectorwise and Typer is the query execution method: vectorized versus data-centric compiled execution.</p>
<p>为了将执行模型的基本属性与现实系统中发现的偶然差异隔离开来，我们在单个测试系统中实现了基于编译的引擎（Typer）和基于矢量化的引擎（Tectorwise）（可在[16]中找到） ]）。 为了使实验具有直接可比性，两种实现都使用相同的算法和数据结构。 测试查询时，我们使用相同的物理查询计划进行矢量化和编译执行。 我们的测量中不包括查询解析、优化、代码生成和编译时间。 这种测试方法允许对两种方法进行同类比较，因为 Tectorwise 和 Typer 之间的唯一区别是查询执行方法：矢量化与以数据为中心的编译执行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/21/%E8%AE%BA%E6%96%87/2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Leoric">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoirc's Blogs">
      <meta itemprop="description" content="十年生死两茫茫，写代码，到天亮。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Leoirc's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/21/%E8%AE%BA%E6%96%87/2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-21 16:59:31" itemprop="dateCreated datePublished" datetime="2022-01-21T16:59:31+08:00">2022-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-07-21 17:40:01" itemprop="dateModified" datetime="2023-07-21T17:40:01+08:00">2023-07-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="MonetDB-x2F-X100-Hyper-Pipelining-Query-Execution"><a href="#MonetDB-x2F-X100-Hyper-Pipelining-Query-Execution" class="headerlink" title="MonetDB&#x2F;X100: Hyper-Pipelining Query Execution"></a>MonetDB&#x2F;X100: Hyper-Pipelining Query Execution</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Database systems tend to achieve only low IPC (instructions-per-cycle) efficiency on modern CPUs in compute-intensive applica- tion areas like decision support, OLAP and multimedia retrieval. This paper starts with an in-depth investigation to the reason why this happens, focusing on the TPC-H bench- mark. Our analysis of various relational sys- tems and MonetDB leads us to a new set of guidelines for designing a query processor.</p>
<p>在决策支持、OLAP 和多媒体检索等计算密集型应用领域，数据库系统在现代 CPU 上往往只能实现较低的 IPC（每周期指令）效率。 本文首先深入调查发生这种情况的原因，重点关注 TPC-H 基准。 我们对各种关系系统和 MonetDB 的分析为我们提供了一套用于设计查询处理器的新指南。</p>
<p>The second part of the paper describes the architecture of our new X100 query engine for the MonetDB system that follows these guidelines. On the surface, it resembles a classical Volcano-style engine, but the cru- cial difference to base all execution on the concept of vector processing makes it highly CPU efficient. We evaluate the power of Mon- etDB&#x2F;X100 on the 100GB version of TPC-H, showing its raw execution power to be between one and two orders of magnitude higher than previous technology.</p>
<p>本文的第二部分描述了遵循这些准则的 MonetDB 系统的新 X100 查询引擎的架构。 从表面上看，它类似于经典的火山式引擎，但关键的区别是所有执行都基于矢量处理概念，这使得它具有很高的 CPU 效率。 我们在 100GB 版本的 TPC-H 上评估了 MonetDB&#x2F;X100 的性能，结果显示其原始执行能力比以前的技术高出一到两个数量级。</p>
<h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><p>Modern CPUs can perform enormous amounts of calculations per second, but only if they can find enough independent work to exploit their parallel execution capabilities. Hardware developments during the past decade have significantly increased the speed difference between a CPU running at full throughput and mini- mal throughput, which can now easily be an order of magnitude.</p>
<p>现代 CPU 每秒可以执行大量计算，但前提是它们能够找到足够的独立工作来利用其并行执行能力。 过去十年的硬件发展显着增加了以全吞吐量和最小吞吐量运行的 CPU 之间的速度差异，现在很容易达到一个数量级。</p>
<p>One would expect that query-intensive database workloads such as decision support, OLAP, data- mining, but also multimedia retrieval, all of which re- quire many independent calculations, should provide modern CPUs the opportunity to get near optimal IPC (instructions-per-cycle) efficiencies.</p>
<p>人们期望查询密集型数据库工作负载，例如决策支持、OLAP、数据挖掘以及多媒体检索，所有这些都需要许多独立计算，应该为现代 CPU 提供接近最佳 IPC（每周期指令）效率的机会。</p>
<p>However, research has shown that database systems tend to achieve low IPC efficiency on modern CPUs in these application areas [6, 3]. We question whether it should really be that way. Going beyond the (im- portant) topic of cache-conscious query processing, we investigate in detail how relational database systems interact with modern super-scalar CPUs in query- intensive workloads, in particular the TPC-H decision support benchmark.</p>
<p>然而，研究表明，在这些应用领域中，数据库系统在现代 CPU 上往往会实现较低的 IPC 效率 [6, 3]。 我们质疑事情是否真的应该如此。 除了缓存感知查询处理的（重要）主题之外，我们还详细研究了关系数据库系统如何在查询密集型工作负载中与现代超标量 CPU 交互，特别是 TPC-H 决策支持基准测试。</p>
<p>The main conclusion we draw from this investiga- tion is that the architecture employed by most DBMSs inhibits compilers from using their most performance- critical optimization techniques, resulting in low CPU efficiencies. Particularly, the common way to im- plement the popular Volcano [10] iterator model for pipelined processing, leads to tuple-at-a-time execu- tion, which causes both high interpretation overhead, and hides opportunities for CPU parallelism from the compiler.</p>
<p>我们从这项调查中得出的主要结论是，大多数 DBMS 采用的体系结构禁止编译器使用对性能最关键的优化技术，从而导致 CPU 效率低下。 特别是，实现流行的 Volcano [10] 迭代器模型进行流水线处理的常见方法会导致一次执行一个元组，这会导致高解释开销，并隐藏编译器的 CPU 并行机会。</p>
<p>We also analyze the performance of the main mem- ory database system MonetDB1, developed in our group, and its MIL query language [4]. MonetDB&#x2F;MIL uses a column-at-a-time execution model, and there- fore does not suffer from problems generated by tuple- at-a-time interpretation. However, its policy of full column materialization causes it to generate large data streams during query execution. On our decision sup- port workload, we found MonetDB&#x2F;MIL to become heavily constrained by memory bandwidth, causing its CPU efficiency to drop sharply.</p>
<p>我们还分析了我们小组开发的主存数据库系统MonetDB1及其MIL查询语言的性能[4]。 MonetDB&#x2F;MIL 使用一次列执行模型，因此不会遇到一次元组解释产生的问题。 然而，其全列具体化策略导致其在查询执行期间生成大量数据流。 在我们的决策支持工作负载上，我们发现 MonetDB&#x2F;MIL 受到内存带宽的严重限制，导致其 CPU 效率急剧下降。</p>
<p>Therefore, we argue for combining the column-wise execution of MonetDB with the incremental material- ization offered by Volcano-style pipelining.</p>
<p>因此，我们主张将 MonetDB 的按列执行与火山式管道提供的增量物化相结合。</p>
<p>We designed and implemented from scratch a new query engine for the MonetDB system, called X100,that employs a vectorized query processing model. Apart from achieving high CPU efficiency, Mon- etDB&#x2F;X100 is intended to scale up towards non main- memory (disk-based) datasets. The second part of this paper is dedicated to describing the architecture of MonetDB&#x2F;X100 and evaluating its performance on the full TPC-H benchmark of size 100GB.</p>
<p>我们从头开始为 MonetDB 系统设计并实现了一个新的查询引擎，称为 X100，它采用矢量化查询处理模型。 除了实现高 CPU 效率外，MonetDB&#x2F;X100 还旨在扩展到非主存（基于磁盘）数据集。 本文的第二部分致力于描述 MonetDB&#x2F;X100 的架构，并在大小为 100GB 的完整 TPC-H 基准测试上评估其性能。</p>
<h4 id="1-1-Outline"><a href="#1-1-Outline" class="headerlink" title="1.1 Outline"></a>1.1 Outline</h4><p>This paper is organized as follows. Section 2 provides an introduction to modern super-scalar (or hyper- pipelined) CPUs, covering the issues most relevant for query evaluation performance. In Section 3, we study TPC-H Query 1 as a micro-benchmark of CPU effi- ciency, first for standard relational database systems, then in MonetDB, and finally we descend into a stan- dalone hand-coded implementation of this query to get a baseline of maximum achievable raw performance.</p>
<p>本文的结构如下。 第 2 节介绍了现代超标量（或超流水线）CPU，涵盖了与查询评估性能最相关的问题。 在第 3 节中，我们研究 TPC-H 查询 1 作为 CPU 效率的微基准，首先针对标准关系数据库系统，然后在 MonetDB 中，最后我们深入研究该查询的独立手动编码实现，以获得最大可实现的原始性能的基线。</p>
<p>Section 4 describes the architecture of our new X100 query processor for MonetDB, focusing on query exe- cution, but also sketching topics like data layout, in- dexing and updates.</p>
<p>第 4 节描述了用于 MonetDB 的新 X100 查询处理器的架构，重点关注查询执行，但也概述了数据布局、索引和更新等主题。</p>
<p>In Section 5, we present a performance comparison of MIL and X100 inside the Monet system on the TPC- H benchmark. We discuss related work in Section 6, before concluding in Section 7.</p>
<p>在第 5 节中，我们在 TPC-H 基准上对 Monet 系统内的 MIL 和 X100 进行了性能比较。 我们在第 6 节中讨论相关工作，然后在第 7 节中进行总结。</p>
<h3 id="2-How-CPUs-Work"><a href="#2-How-CPUs-Work" class="headerlink" title="2 How CPUs Work"></a>2 How CPUs Work</h3><p>Figure 1 displays for each year in the past decade the fastest CPU available in terms of MHz, as well as high- est performance (one thing does not necessarily equate the other), as well as the most advanced chip manu- facturing technology in production that year.</p>
<p>图 1 显示了过去十年中每年最快的 CPU（以 MHz 计）、最高性能（一件事并不一定等同于另一件事），以及当年生产的最先进的芯片制造技术。</p>
<p>![image-20230721101311979](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230721101311979.png)</p>
<p>The root cause for CPU MHz improvements is progress in chip manufacturing process scales, that typically shrink by a factor 1.4 every 18 months (a.k.a. Moore’s law [13]). Every smaller manufacturing scale means twice (the square of 1.4) as many, and twice smaller transistors, as well as 1.4 times smaller wire distances and signal latencies. Thus one would expect CPU MHz to increase with inverted signal latencies, but Figure 1 shows that clock speed has increased even further. This is mainly done by pipelining: dividing the work of a CPU instruction in ever more stages. Less work per stage means that the CPU frequency can be increased. While the 1988 Intel 80386 CPU executed one instruction in one (or more) cycles, the 1993 Pentium already had a 5-stage pipeline, to be in- creased in the 1999 PentiumIII to 14 while the 2004 Pentium4 has 31 pipeline stages.</p>
<p>CPU MHz 改进的根本原因是芯片制造工艺规模的进步，通常每 18 个月缩小 1.4 倍（又称摩尔定律 [13]）。 制造规模每缩小一倍，晶体管数量就会增加一倍（1.4 的平方），晶体管尺寸也会缩小一倍，布线距离和信号延迟也会缩小 1.4 倍。 因此，人们预计 CPU MHz 会随着反转信号延迟而增加，但图 1 显示时钟速度甚至进一步增加。 这主要是通过流水线来完成的：将 CPU 指令的工作划分为更多阶段。 每个阶段的工作量减少意味着可以提高 CPU 频率。 1988 年的 Intel 80386 CPU 在一个（或多个）周期内执行一条指令，而 1993 年的 Pentium 已经有 5 级流水线，在 1999 年的 PentiumIII 中增加到 14 级，而 2004 年的 Pentium4 有 31 级流水线。</p>
<p>Pipelines introduce two dangers: (i) if one instruc- tion needs the result of a previous instruction, it can- not be pushed into the pipeline right after it, but must wait until the first instruction has passed through the pipeline (or a significant fraction thereof), and (ii) in case of IF-a-THEN-b-ELSE-c branches, the CPU must predict whether a will evaluate to true or false. It might guess the latter and put c into the pipeline, just after a. Many stages further, when the evaluation of a finishes, it may determine that it guessed wrongly (i.e. mispredicted the branch), and then must flush the pipeline (discard all instructions in it) and start over with b. Obviously, the longer the pipeline, the more instructions are flushed away and the higher the performance penalty. Translated to database systems, branches that are data-dependent, such as those found in a selection operator on data with a selectivity that is neither very high nor very low, are impossible to predict and can significantly slow down query execu- tion [17].</p>
<p>管道引入了两个危险：（i）如果一条指令需要前一条指令的结果，则不能立即将其推入管道，而必须等到第一条指令（或其大部分）通过管道，以及（ii）在 IF-a-THEN-b-ELSE-c 分支的情况下，CPU 必须预测 a 的计算结果是 true 还是 false。 它可能会猜到后者并将 c 放入管道中，就在 a 之后。 进一步的许多阶段，当 a 的评估完成时，它可能会确定它猜测错误（即错误预测了分支），然后必须刷新管道（丢弃其中的所有指令）并从 b 重新开始。 显然，管道越长，被冲走的指令就越多，性能损失就越高。 转换到数据库系统中，依赖于数据的分支（例如在选择性既不是很高也不是很低的数据的选择运算符中发现的分支）是无法预测的，并且会显着减慢查询执行速度[17]。</p>
<p>In addition, super-scalar CPUs2 offer the possibility to take multiple instructions into execution in parallel if they are independent. That is, the CPU has not one, but multiple pipelines. Each cycle, a new instruction can be pushed into each pipeline, provided again they are independent of all instructions already in execu- tion. A super-scalar CPU can get to an IPC (Instruc- tions Per Cycle) of &gt; 1. Figure 1 shows that this has allowed real-world CPU performance to increase faster than CPU frequency.</p>
<p>此外，超标量 CPU2 还提供了并行执行多条指令（如果它们是独立的）的可能性。 也就是说，CPU不是一条，而是多条流水线。 每个周期，都可以将新指令推入每个流水线，前提是它们再次独立于已执行的所有指令。 超标量 CPU 的 IPC（每周期指令数）可以大于 1。图 1 显示，这使得现实世界的 CPU 性能比 CPU 频率的增长速度更快。</p>
<p>Modern CPUs are balanced in different ways. The Intel Itanium2 processor is a VLIW (Very Large In- struction Word) processor with many parallel pipelines (it can execute up to 6 instructions per cycle) with only few (7) stages, and therefore a relatively low clock speed of 1.5GHz. In contrast, the Pentium4 has its very long 31-stage pipeline allowing for a 3.6GHz clock speed, but can only execute 3 instructions per cycle. Either way, to get to its theoretical maximum through- put, an Itanium2 needs 7x6 &#x3D; 42 independent instruc- tions at any time, while the Pentium4 needs 31x3 &#x3D; 93. Such parallelism cannot always be found, and there- fore many programs use the resources of the Itanium2 much better than the Pentium4, which explains why in benchmarks the performance of both CPUs is similar, despite the big clock speed difference.</p>
<p>现代 CPU 以不同的方式实现平衡。 Intel Itanium2 处理器是一款 VLIW（超大型指令字）处理器，具有许多并行管道（每个周期最多可以执行 6 条指令），只有很少 (7) 个级，因此时钟速度相对较低，为 1.5GHz。 相比之下，Pentium4 拥有非常长的 31 级流水线，可实现 3.6GHz 时钟速度，但每个周期只能执行 3 条指令。 不管怎样，为了达到理论上的最大吞吐量，Itanium2 在任何时候都需要 7x6 &#x3D; 42 条独立指令，而 Pentium4 则需要 31x3 &#x3D; 93 条。这种并行性并不总是能够找到，因此许多程序使用 Itanium2 的资源比 Pentium4 好得多，这解释了为什么在基准测试中，尽管时钟速度差异很大，但两种 CPU 的性能相似。</p>
<p>Most programming languages do not require programmers to explicitly specify in their programs which instructions (or expressions) are independent Therefore, compiler optimizations have become crit- ical to achieving good CPU utilization. The most important technique is loop pipelining, in which an operation consisting of multiple dependent operations F(), G() on all n independent elements of an array A is transformed from:</p>
<p>大多数编程语言不要求程序员在程序中显式指定哪些指令（或表达式）是独立的。因此，编译器优化对于实现良好的 CPU 利用率至关重要。 最重要的技术是循环流水线，其中由对数组 A 的所有 n 个独立元素进行的多个相关操作 F()、G() 组成的操作转换为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F(A[<span class="number">0</span>]),G(A[<span class="number">0</span>]), F(A[<span class="number">1</span>]),G(A[<span class="number">1</span>]),.. F(A[n]),G(A[n])</span><br><span class="line">into:</span><br><span class="line">F(A[<span class="number">0</span>]),F(A[<span class="number">1</span>]),F(A[<span class="number">2</span>]), G(A[<span class="number">0</span>]),G(A[<span class="number">1</span>]),G(A[<span class="number">2</span>]), F(A[<span class="number">3</span>]),..</span><br></pre></td></tr></table></figure>

<p>Supposing the pipeline dependency latency of F() is 2 cycles, when G(A[0]) is taken into execution, the result of F(A[0]) has just become available.</p>
<p>假设F()的流水线依赖延迟为2个周期，当G(A[0])执行时，F(A[0])的结果刚刚可用。</p>
<p>In the case of the Itanium2 processor, the impor- tance of the compiler is even stronger, as it is the compiler which has to find instructions that can go into different pipelines (other CPUs do that at run- time, using out-of-order execution). As the Itanium2 chip does not need any complex logic dedicated to find- ing out-of-order execution opportunities, it can contain more pipelines that do real work. The Itanium2 also has a feature called branch predication for eliminating branch mispredictions, by allowing to execute both the THEN and ELSE blocks in parallel and discard one of the results as soon as the result of the condition becomes known. It is also the task of the compiler to detect opportunities for branch predication.</p>
<p>对于 Itanium2 处理器，编译器的重要性甚至更强，因为编译器必须找到可以进入不同管道的指令（其他 CPU 在运行时使用乱序执行来执行此操作）。 由于 Itanium2 芯片不需要任何专门用于查找乱序执行机会的复杂逻辑，因此它可以包含更多执行实际工作的管道。 Itanium2 还具有称为分支预测的功能，允许并行执行 THEN 和 ELSE 块，并在条件结果已知后立即丢弃其中一个结果，从而消除分支错误预测。 检测分支预测的机会也是编译器的任务。</p>
<p>Figure 2 shows a micro-benchmark of the selection query SELECT oid FROM table WHERE col &lt; X, where X is uniformly and randomly distributed over [0:100] and we vary the selectivity X between 0 and 100. Nor- mal CPUs like the AthlonMP show worst-case behav- ior around 50%, due to branch mispredictions. As sug- gested in [17], by rewriting the code cleverly, we can transform the branch into a boolean calculation (the “predicated” variant). Performance of this rewritten variant is independent of the selectivity, but incurs a higher average cost. Interestingly, the “branch” vari- ant on Itanium2 is highly efficient and independent of selectivity as well, because the compiler transforms the branch into hardware-predicated code.</p>
<p>图 2 显示了选择查询 SELECT oid FROM table WHERE col &lt; X 的微基准，其中 X 在 [0:100] 上均匀随机分布，我们将选择性 X 在 0 到 100 之间变化。由于分支预测错误，像 AthlonMP 这样的普通 CPU 显示出大约 50% 的最坏情况行为。 正如[17]中所建议的，通过巧妙地重写代码，我们可以将分支转换为布尔计算（“谓词”变体）。 这种重写变体的性能与选择性无关，但会产生更高的平均成本。 有趣的是，Itanium2 上的“分支”变体非常高效并且与选择性无关，因为编译器将分支转换为硬件谓词代码。</p>
<p>![image-20230721163034200](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230721163034200.png)</p>
<p>Finally, we should mention the importance of onchip caches to CPU throughput. About 30% of all instructions executed by a CPU are memory loads and stores, that access data on DRAM chips, located inches away from the CPU on a motherboard. This imposes a physical lower bound on memory latency of around 50 ns. This (ideal) minimum latency of 50ns already translates into 180 wait cycles for a 3.6GHz CPU. Thus, only if the overwhelming majority of the memory accessed by a program can be found in an on- chip cache, a modern CPU has a chance to operate at its maximum throughput. Recent database research has shown that DBMS performance is strongly im- paired by memory access cost (“cache misses”) [3], and can significantly improve if cache-conscious data struc- tures are used, such as cache-aligned B-trees [16, 7] or column-wise data layouts such as PAX [2] and DSM [8] (as in MonetDB). Also, query processing algorithms that restrict their random memory access patterns to regions that fit a CPU cache, such as radix-partitioned hash-join [18, 11], strongly improve performance.</p>
<p>最后，我们应该提到片上缓存对 CPU 吞吐量的重要性。 CPU 执行的所有指令中大约 30% 是内存加载和存储，它们访问 DRAM 芯片上的数据，这些芯片距离主板上的 CPU 几英寸远。 这使得内存延迟的物理下限约为 50 ns。 对于 3.6GHz CPU，50ns 的（理想）最小延迟已经转化为 180 个等待周期。 因此，只有当程序访问的绝大多数内存都可以在片上高速缓存中找到时，现代 CPU 才有机会以其最大吞吐量运行。 最近的数据库研究表明，DBMS 的性能受到内存访问成本（“缓存未命中”）[3] 的严重影响，如果使用缓存敏感的数据结构，例如缓存对齐的 B 树 [16, 7] 或按列的数据布局，例如 PAX [2] 和 DSM [8]（如 MonetDB 中），则可以显着提高性能。 此外，将随机内存访问模式限制在适合 CPU 缓存的区域的查询处理算法（例如基数分区哈希连接 [18, 11]）可以极大地提高性能。</p>
<p>All in all, CPUs have become highly complex de- vices, where the instruction throughput of a processor can vary by orders of magnitude (!) depending on the cache hit-ratio of the memory loads and stores, the number of branches and whether they can be pre- dicted&#x2F;predicated, as well as the amount of indepen- dent instructions a compiler and the CPU can detect on average. It has been shown that query execution in commercial DBMS systems get an IPC of only 0.7 [6], thus executing less than one instruction per cycle. In contrast, scientific computation (e.g. matrix multipli- cation) or multimedia processing does extract average IPCs of up to 2 out of modern CPUs. We argue that database systems do not need to perform so badly, especially not on large-scale analysis tasks, where mil- lions of tuples need to be examined and expressions to be calculated. This abundance of work contains plenty of independence that should be able to fill all the pipelines a CPU can offer. Hence, our quest is to adapt database architecture to expose this to the com- piler and CPU where possible, and thus significantly improve query processing throughput.</p>
<p>总而言之，CPU 已经成为高度复杂的设备，处理器的指令吞吐量可能会发生几个数量级的变化（！），具体取决于内存加载和存储的缓存命中率、分支数量以及它们是否可以预测&#x2F;谓词，以及编译器和 CPU 平均可以检测到的独立指令的数量。 研究表明，商业 DBMS 系统中的查询执行的 IPC 仅为 0.7 [6]，因此每个周期执行的指令少于一条。 相比之下，科学计算（例如矩阵乘法）或多媒体处理确实可以从现代 CPU 中提取最多 2 个平均 IPC。 我们认为数据库系统不需要表现得如此糟糕，尤其是在大规模分析任务上，其中需要检查数百万个元组并计算表达式。 如此丰富的工作包含大量的独立性，应该能够填充 CPU 可以提供的所有管道。 因此，我们的目标是调整数据库架构，尽可能将其暴露给编译器和 CPU，从而显着提高查询处理吞吐量。</p>
<h3 id="3-Microbenchmark-TPC-H-Query-1"><a href="#3-Microbenchmark-TPC-H-Query-1" class="headerlink" title="3 Microbenchmark: TPC-H Query 1"></a>3 Microbenchmark: TPC-H Query 1</h3><p>While we target CPU efficiency of query processing in general, we first focus on expression calculation, dis- carding more complex relational operations (like join) to simplify our analysis. We choose Query 1 of the TPC-H benchmark, shown in Figure 3, this query is CPU-bound because on all RDBMSs we tested. Also, this query requires virtually no optimization or fancy join implementations as its plan is so simple. Thus, all database systems operate on a level playing field and mainly expose their expression evaluation efficiency.</p>
<p>虽然我们总体上以查询处理的 CPU 效率为目标，但我们首先关注表达式计算，放弃更复杂的关系操作（如连接）以简化我们的分析。 我们选择 TPC-H 基准测试的查询 1，如图 3 所示，该查询受 CPU 限制，因为在我们测试的所有 RDBMS 上。 此外，该查询实际上不需要优化或花哨的连接实现，因为它的计划非常简单。 因此，所有数据库系统都在公平的竞争环境中运行，主要暴露其表达评估效率。</p>
<p>The TPC-H benchmark operates on a data warehouse of 1GB, the size of which can be increased with a Scaling Factor (SF). Query 1 is a scan on the lineitem table of SF<em>6M tuples, that selects almost all tu- ples (SF</em>5.9M), and computes a number of fixed-point decimal expressions: two column-to-constant subtrac- tions, one column-to-constant addition, three column- to-column multiplications, and eight aggregates (four SUM()s, three AVG()s and a COUNT()). The aggre- gate grouping is on two single-character columns, and yields only 4 unique combinations, such that it can be done efficiently with a small hash-table, requiring no additional I&#x2F;O nor even CPU cache misses (for access- ing the hash-table).</p>
<p>TPC-H 基准测试在 1GB 的数据仓库上运行，其大小可以通过缩放因子 (SF) 来增加。 查询 1 是对 SF<em>6M 元组的 lineitem 表的扫描，它选择几乎所有元组 (SF</em>5.9M)，并计算许多定点十进制表达式：两个列到常量减法、一个列到常量加法、三个列到列乘法和八个聚合（四个 SUM()、三个 AVG() 和一个 COUNT()）。 聚合分组位于两个单字符列上，仅产生 4 个唯一组合，因此可以使用小型哈希表高效完成，不需要额外的 I&#x2F;O，甚至不需要 CPU 缓存未命中（用于访问哈希表）。</p>
<p>In the following, we analyze the performance of Query 1 first on relational database systems, then on MonetDB&#x2F;MIL and finally in a hand-coded program.</p>
<p>下面，我们首先分析查询 1 在关系数据库系统上的性能，然后在 MonetDB&#x2F;MIL 上，最后在手动编码程序中的性能。</p>
<p>![image-20230721163533791](&#x2F;Users&#x2F;leoric&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230721163533791.png)</p>
<h4 id="3-1-Query-1-on-Relational-Database-Systems"><a href="#3-1-Query-1-on-Relational-Database-Systems" class="headerlink" title="3.1 Query 1 on Relational Database Systems"></a>3.1 Query 1 on Relational Database Systems</h4><p>Since the early days of RDBMSs, query execution functionality is provided by implementing a physical relational algebra, typically following the Volcano [10] model of pipelined processing. Relational algebra, however, has a high degree of freedom in its param- eters. For instance, even a simple ScanSelect(R, b, P ) only at query-time receives full knowledge of the for- mat of the input relation R (number of columns, their types, and record offsets), the boolean selection ex- pression b (which may be of any form), and a list of projection expressions P (each of arbitrary com- plexity) that define the output relation. In order to deal with all possible R, b, and P , DBMS implemen- tors must in fact implement an expression interpreter that can handle expressions of arbitrary complexity.</p>
<p>从 RDBMS 的早期开始，查询执行功能是通过实现物理关系代数来提供的，通常遵循管道处理的 Volcano [10] 模型。 然而，关系代数的参数具有很高的自由度。 例如，即使是一个简单的 ScanSelect(R, b, P )，也只能在查询时接收输入关系 R 的格式（列数、列的类型和记录偏移量）、布尔选择表达式 b（可以是任何形式）以及定义输出关系的投影表达式 P 的列表（每个表达式的复杂度是任意的）。 为了处理所有可能的 R、b 和 P，DBMS 实现者实际上必须实现一个可以处理任意复杂度表达式的表达式解释器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> l_returnflag, l_linestatus,</span><br><span class="line">				<span class="built_in">sum</span>(l_quantity) <span class="keyword">AS</span> sum_qty,</span><br><span class="line">				<span class="built_in">sum</span>(l_extendedprice) <span class="keyword">AS</span> sum_base_price,</span><br><span class="line">				<span class="built_in">sum</span>(l_extendedprice <span class="operator">*</span> (<span class="number">1</span> <span class="operator">-</span> l_discount))</span><br><span class="line">					<span class="keyword">AS</span> sum_disc_price,</span><br><span class="line">				<span class="built_in">sum</span>(l_extendedprice <span class="operator">*</span> (<span class="number">1</span> <span class="operator">-</span> l_discount) <span class="operator">*</span></span><br><span class="line">            (<span class="number">1</span> <span class="operator">+</span> l_tax)) <span class="keyword">AS</span> sum_charge,</span><br><span class="line">        <span class="built_in">avg</span>(l_quantity) <span class="keyword">AS</span> avg_qty,</span><br><span class="line">        <span class="built_in">avg</span>(l_extendedprice) <span class="keyword">AS</span> avg_price,</span><br><span class="line">        <span class="built_in">avg</span>(l_discount) <span class="keyword">AS</span> avg_disc,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> count_order</span><br><span class="line"><span class="keyword">FROM</span>		lineitem</span><br><span class="line"><span class="keyword">WHERE</span> l_shipdate <span class="operator">&lt;=</span> <span class="type">date</span> ’<span class="number">1998</span><span class="number">-09</span><span class="number">-02</span>’</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> l_returnflag, l_linestatus</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Figure <span class="number">3</span>: TPC<span class="operator">-</span>H Query <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>One of the dangers of such an interpreter, especially if the granularity of interpretation is a tuple, is that the cost of the “real work” (i.e. executing the expres- sions found in the query) is only a tiny fraction of total query execution cost. We can see this happen- ing in Table 2 that shows a gprof trace of a MySQL 4.1 of TPC-H Query 1 on a database of SF&#x3D;1. The second column shows the percentage of total execu- tion time spent in the routine, excluding time spent in routines it called (excl.). The first column is a cu- mulative sum of the second (cum.). The third column lists how many times the routine was called, while the fourth and fifth columns show the average number of instructions executed on each call, as well as the IPC achieved.</p>
<p>这种解释器的危险之一，特别是当解释的粒度是一个元组时，是“实际工作”的成本（即执行查询中找到的表达式）仅占总查询执行成本的一小部分。 我们可以在表 2 中看到这种情况的发生，该表显示了 SF&#x3D;1 数据库上 TPC-H 查询 1 的 MySQL 4.1 的 gprof 跟踪。 第二列显示在例程中花费的总执行时间的百分比，不包括在它调用的例程中花费的时间（排除）。 第一列是第二列的累积和 (cum.)。 第三列列出了例程被调用的次数，而第四列和第五列显示了每次调用时执行的平均指令数以及实现的 IPC。</p>
<p>The first observation to make is that the five oper- ations that do all the “work” (displayed in boldface), correspond to only 10% of total execution time. Closer inspection shows that 28% of execution time is taken up by creation and lookup in the hash-table used for aggregation. The remaining 62% of execution time is spread over functions like rec get nth field, that navi- gate through MySQL’s record representation and copy data in and out of it. Other factors, such as locking overhead (pthread mutex unlock, mutex test and set) or buffer page allocation (buf frame align) seem to play only a minor role in this decision support query.</p>
<p>第一个观察结果是，完成所有“工作”（以粗体显示）的五个操作仅相当于总执行时间的 10%。 仔细检查表明，28% 的执行时间被用于聚合的哈希表中的创建和查找占用。 剩下的 62% 的执行时间分布在像 rec get nth field 这样的函数上，这些函数遍历 MySQL 的记录表示并将数据复制进出。 其他因素，例如锁定开销（pthread 互斥体解锁、互斥体测试和设置）或缓冲区页面分配（buf 帧对齐）似乎在此决策支持查询中仅发挥次要作用。</p>
<p>The second observation is the cost of the Item op- erations that correspond to the computational “work” of the query. For example, Item func plus::val has a cost of 38 instructions per addition. This performance trace was made on an SGI machine with MIPS R12000 CPU3, which can execute three integer or floating- point instructions and one load&#x2F;store per cycle, with an average operation latency of about 5 cycles. A sim- ple arithmetic operation +(double src1, double src2) : double in RISC instructions would look like:</p>
<p>第二个观察结果是与查询的计算“工作”相对应的项目操作的成本。 例如，Item func plus::val 每次加法的成本为 38 条指令。 此性能跟踪是在配备 MIPS R12000 CPU3 的 SGI 机器上进行的，该机器可以执行 3 个整数或浮点指令，每个周期执行一次加载&#x2F;存储，平均操作延迟约为 5 个周期。 RISC 指令中的简单算术运算 +(double src1, double src2) : double 如下所示：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD src<span class="number">1</span>,re<span class="name">g1</span></span><br><span class="line">LOAD src<span class="number">2</span>,re<span class="name">g2</span></span><br><span class="line">ADD re<span class="name">g1</span>,re<span class="name">g2</span>,re<span class="name">g3</span></span><br><span class="line">STOR dst,re<span class="name">g3</span></span><br></pre></td></tr></table></figure>

<p>The limiting factor in this code are the three load&#x2F;store instructions, thus a MIPS processor can do one *(double,double) per 3 cycles. This is in sharp contrast to the MySQL cost of #ins&#x2F;Instruction-Per- Cycle (IPC) &#x3D; 38&#x2F;0.8 &#x3D; 49 cycles! One explanation for this high cost is the absence of loop pipelining. As the routine called by MySQL only computes one ad- dition per call, instead of an array of additions, the compiler cannot perform loop pipelining. Thus, the addition consists of four dependent instructions that have to wait for each other. With a mean instruction latency of 5 cycles, this explains a cost of about 20 cycles. The rest of the 49 cycles are spent on jumping into the routine, and pushing and popping the stack.</p>
<p>该代码中的限制因素是三个加载&#x2F;存储指令，因此 MIPS 处理器每 3 个周期可以执行一次 *(double,double)。 这与 #ins&#x2F;每周期指令 (IPC) &#x3D; 38&#x2F;0.8 &#x3D; 49 个周期的 MySQL 成本形成鲜明对比！ 造成如此高成本的一个原因是缺乏循环流水线。 由于 MySQL 调用的例程每次调用仅计算一次加法，而不是一组加法，因此编译器无法执行循环流水线操作。 因此，加法由四个必须相互等待的相关指令组成。 平均指令延迟为 5 个周期，这解释了大约 20 个周期的成本。 其余 49 个周期用于跳转到例程以及压入和弹出堆栈。</p>
<p>The consequence of the MySQL policy to execute expressions tuple-at-a-time, is twofold:</p>
<p>MySQL 一次执行一个元组表达式的策略的结果是双重的：</p>
<ul>
<li><p>Item func plus::val only performs one addition, preventing the compiler from creating a pipelined loop. As the instructions for one operation are highly dependent, empty pipeline slots must be generated (stalls) to wait for the instruction la- tencies, such that the cost of the loop becomes 20 instead of 3 cycles.</p>
<p> Item func plus::val 仅执行一次加法，从而防止编译器创建管道循环。 由于一项操作的指令高度依赖，必须生成空的流水线槽（停顿）来等待指令延迟，使得循环成本变为 20 个周期，而不是 3 个周期。</p>
</li>
<li><p>the cost of the routine call (in the ballpark of 20 cycles) must be amortized over only one opera- tion, which effectively doubles the operation cost.</p>
<p>例程调用的成本（大约 20 个周期）必须仅分摊到一次操作上，这实际上使操作成本加倍。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Leoric</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Heoric" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Heoric","repo":"Leoric_comments","client_id":"6b2886f8d76442a0b3a2","client_secret":"2ef0222b05e84b348738c1f9610f3f2cd387f98c","admin_user":"Heoric","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"9d8d3da09189165dcde8f1d3e109ad78"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
<script type="text/javascript" src="/js/clicklove.js"></script>

